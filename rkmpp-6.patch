From e13ddabb7694f8332d95ddc4bc00e37b1f7e2a76 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Wed, 4 Sep 2019 17:24:37 +0800
Subject: [PATCH 01/24] avcodec/rkmppdec: Clear eos flag after reset

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libavcodec/rkmppdec.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 8bf7c6ed16..e31e0c44dc 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -544,6 +544,7 @@ static void rkmpp_flush(AVCodecContext *avctx)
     ret = decoder->mpi->reset(decoder->ctx);
     if (ret == MPP_OK) {
         decoder->first_packet = 1;
+        decoder->eos_reached = 0;
     } else
         av_log(avctx, AV_LOG_ERROR, "Failed to reset MPI (code = %d)\n", ret);
 }
-- 
2.40.0


From 32c3c2a06887dce24c73a8fb65fd90f0d47dc53f Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Wed, 4 Sep 2019 17:27:46 +0800
Subject: [PATCH 02/24] avcodec/rkmppdec: Compatible with old reordered_opaque
 and pkt_pts

Some users might still using these deprecated APIs.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libavcodec/rkmppdec.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index e31e0c44dc..4b4b17c342 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -93,6 +93,9 @@ static int rkmpp_write_data(AVCodecContext *avctx, uint8_t *buffer, int size, in
     int ret;
     MppPacket packet;
 
+    if (!pts || pts == AV_NOPTS_VALUE)
+        pts = avctx->reordered_opaque;
+
     // create the MPP packet
     ret = mpp_packet_init(&packet, buffer, size);
     if (ret != MPP_OK) {
@@ -398,6 +401,7 @@ static int rkmpp_retrieve_frame(AVCodecContext *avctx, AVFrame *frame)
         frame->width            = mpp_frame_get_width(mppframe);
         frame->height           = mpp_frame_get_height(mppframe);
         frame->pts              = mpp_frame_get_pts(mppframe);
+        frame->reordered_opaque = frame->pts;
         frame->color_range      = mpp_frame_get_color_range(mppframe);
         frame->color_primaries  = mpp_frame_get_color_primaries(mppframe);
         frame->color_trc        = mpp_frame_get_color_trc(mppframe);
-- 
2.40.0


From 1839dfc7860999826e5152c0b96938d8772a4739 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Wed, 19 May 2021 09:55:03 +0800
Subject: [PATCH 03/24] rkmppdec: Remove frame buffer limit

It would hang when reaching the limit.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libavcodec/rkmppdec.c | 8 --------
 1 file changed, 8 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 4b4b17c342..d8f48f36b9 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -39,7 +39,6 @@
 #include "libavutil/log.h"
 
 #define RECEIVE_FRAME_TIMEOUT   100
-#define FRAMEGROUP_MAX_FRAMES   16
 #define INPUT_MAX_PACKETS       4
 
 typedef struct {
@@ -241,13 +240,6 @@ static int rkmpp_init_decoder(AVCodecContext *avctx)
         goto fail;
     }
 
-    ret = mpp_buffer_group_limit_config(decoder->frame_group, 0, FRAMEGROUP_MAX_FRAMES);
-    if (ret) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to set buffer group limit (code = %d)\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
     decoder->first_packet = 1;
 
     av_log(avctx, AV_LOG_DEBUG, "RKMPP decoder initialized successfully.\n");
-- 
2.40.0


From 076cca4ad14ac04297aa2cf9786cb7b9b80be07b Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Thu, 20 May 2021 10:19:15 +0800
Subject: [PATCH 04/24] avcodec/rkmppdec: Rework decoding flow

Stop using the deprecated MPP_DEC_GET_STREAM_COUNT API.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libavcodec/rkmppdec.c | 520 ++++++++++++++++++++++--------------------
 1 file changed, 267 insertions(+), 253 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index d8f48f36b9..d3c13297d2 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -38,17 +38,15 @@
 #include "libavutil/imgutils.h"
 #include "libavutil/log.h"
 
-#define RECEIVE_FRAME_TIMEOUT   100
-#define INPUT_MAX_PACKETS       4
-
 typedef struct {
     MppCtx ctx;
     MppApi *mpi;
     MppBufferGroup frame_group;
 
-    char first_packet;
-    char eos_reached;
+    int8_t eos;
+    int8_t draining;
 
+    AVPacket packet;
     AVBufferRef *frames_ref;
     AVBufferRef *device_ref;
 } RKMPPDecoder;
@@ -85,47 +83,13 @@ static uint32_t rkmpp_get_frameformat(MppFrameFormat mppformat)
     }
 }
 
-static int rkmpp_write_data(AVCodecContext *avctx, uint8_t *buffer, int size, int64_t pts)
+static int rkmpp_close_decoder(AVCodecContext *avctx)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
     RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret;
-    MppPacket packet;
 
-    if (!pts || pts == AV_NOPTS_VALUE)
-        pts = avctx->reordered_opaque;
-
-    // create the MPP packet
-    ret = mpp_packet_init(&packet, buffer, size);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to init MPP packet (code = %d)\n", ret);
-        return AVERROR_UNKNOWN;
-    }
-
-    mpp_packet_set_pts(packet, pts);
-
-    if (!buffer)
-        mpp_packet_set_eos(packet);
-
-    ret = decoder->mpi->decode_put_packet(decoder->ctx, packet);
-    if (ret != MPP_OK) {
-        if (ret == MPP_ERR_BUFFER_FULL) {
-            av_log(avctx, AV_LOG_DEBUG, "Buffer full writing %d bytes to decoder\n", size);
-            ret = AVERROR(EAGAIN);
-        } else
-            ret = AVERROR_UNKNOWN;
-    }
-    else
-        av_log(avctx, AV_LOG_DEBUG, "Wrote %d bytes to decoder\n", size);
-
-    mpp_packet_deinit(&packet);
-
-    return ret;
-}
+    av_packet_unref(&decoder->packet);
 
-static int rkmpp_close_decoder(AVCodecContext *avctx)
-{
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
     av_buffer_unref(&rk_context->decoder_ref);
     return 0;
 }
@@ -151,14 +115,32 @@ static void rkmpp_release_decoder(void *opaque, uint8_t *data)
     av_free(decoder);
 }
 
+static int rkmpp_prepare_decoder(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    MppPacket packet;
+    int ret;
+
+    // send extra data
+    if (avctx->extradata_size) {
+        ret = mpp_packet_init(&packet, avctx->extradata, avctx->extradata_size);
+        if (ret < 0)
+            return AVERROR_UNKNOWN;
+        ret = decoder->mpi->decode_put_packet(decoder->ctx, packet);
+        mpp_packet_deinit(&packet);
+        if (ret < 0)
+            return AVERROR_UNKNOWN;
+    }
+    return 0;
+}
+
 static int rkmpp_init_decoder(AVCodecContext *avctx)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
     RKMPPDecoder *decoder = NULL;
     MppCodingType codectype = MPP_VIDEO_CodingUnused;
     int ret;
-    RK_S64 paramS64;
-    RK_S32 paramS32;
 
     avctx->pix_fmt = AV_PIX_FMT_DRM_PRIME;
 
@@ -201,6 +183,9 @@ static int rkmpp_init_decoder(AVCodecContext *avctx)
         goto fail;
     }
 
+    ret = 1;
+    decoder->mpi->control(decoder->ctx, MPP_DEC_SET_PARSER_FAST_MODE, &ret);
+
     // initialize mpp
     ret = mpp_init(decoder->ctx, MPP_CTX_DEC, codectype);
     if (ret != MPP_OK) {
@@ -209,26 +194,9 @@ static int rkmpp_init_decoder(AVCodecContext *avctx)
         goto fail;
     }
 
-    // make decode calls blocking with a timeout
-    paramS32 = MPP_POLL_BLOCK;
-    ret = decoder->mpi->control(decoder->ctx, MPP_SET_OUTPUT_BLOCK, &paramS32);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to set blocking mode on MPI (code = %d).\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
-    paramS64 = RECEIVE_FRAME_TIMEOUT;
-    ret = decoder->mpi->control(decoder->ctx, MPP_SET_OUTPUT_BLOCK_TIMEOUT, &paramS64);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to set block timeout on MPI (code = %d).\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
     ret = mpp_buffer_group_get_internal(&decoder->frame_group, MPP_BUFFER_TYPE_ION);
     if (ret) {
-       av_log(avctx, AV_LOG_ERROR, "Failed to retrieve buffer group (code = %d)\n", ret);
+       av_log(avctx, AV_LOG_ERROR, "Failed to get buffer group (code = %d)\n", ret);
        ret = AVERROR_UNKNOWN;
        goto fail;
     }
@@ -240,7 +208,13 @@ static int rkmpp_init_decoder(AVCodecContext *avctx)
         goto fail;
     }
 
-    decoder->first_packet = 1;
+    decoder->mpi->control(decoder->ctx, MPP_DEC_SET_DISABLE_ERROR, NULL);
+
+    ret = rkmpp_prepare_decoder(avctx);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to prepare decoder (code = %d)\n", ret);
+        goto fail;
+    }
 
     av_log(avctx, AV_LOG_DEBUG, "RKMPP decoder initialized successfully.\n");
 
@@ -261,44 +235,6 @@ fail:
     return ret;
 }
 
-static int rkmpp_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
-{
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret;
-
-    // handle EOF
-    if (!avpkt->size) {
-        av_log(avctx, AV_LOG_DEBUG, "End of stream.\n");
-        decoder->eos_reached = 1;
-        ret = rkmpp_write_data(avctx, NULL, 0, 0);
-        if (ret)
-            av_log(avctx, AV_LOG_ERROR, "Failed to send EOS to decoder (code = %d)\n", ret);
-        return ret;
-    }
-
-    // on first packet, send extradata
-    if (decoder->first_packet) {
-        if (avctx->extradata_size) {
-            ret = rkmpp_write_data(avctx, avctx->extradata,
-                                            avctx->extradata_size,
-                                            avpkt->pts);
-            if (ret) {
-                av_log(avctx, AV_LOG_ERROR, "Failed to write extradata to decoder (code = %d)\n", ret);
-                return ret;
-            }
-        }
-        decoder->first_packet = 0;
-    }
-
-    // now send packet
-    ret = rkmpp_write_data(avctx, avpkt->data, avpkt->size, avpkt->pts);
-    if (ret && ret!=AVERROR(EAGAIN))
-        av_log(avctx, AV_LOG_ERROR, "Failed to write data to decoder (code = %d)\n", ret);
-
-    return ret;
-}
-
 static void rkmpp_release_frame(void *opaque, uint8_t *data)
 {
     AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)data;
@@ -312,7 +248,7 @@ static void rkmpp_release_frame(void *opaque, uint8_t *data)
     av_free(desc);
 }
 
-static int rkmpp_retrieve_frame(AVCodecContext *avctx, AVFrame *frame)
+static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
     RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
@@ -327,151 +263,159 @@ static int rkmpp_retrieve_frame(AVCodecContext *avctx, AVFrame *frame)
     MppFrameFormat mppformat;
     uint32_t drmformat;
 
+    // should not provide any frame after EOS
+    if (decoder->eos)
+        return AVERROR_EOF;
+
+    decoder->mpi->control(decoder->ctx, MPP_SET_OUTPUT_TIMEOUT, (MppParam)&timeout);
+
     ret = decoder->mpi->decode_get_frame(decoder->ctx, &mppframe);
     if (ret != MPP_OK && ret != MPP_ERR_TIMEOUT) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to get a frame from MPP (code = %d)\n", ret);
-        goto fail;
+        av_log(avctx, AV_LOG_ERROR, "Failed to get frame (code = %d)\n", ret);
+        return AVERROR_UNKNOWN;
     }
 
-    if (mppframe) {
-        // Check whether we have a special frame or not
-        if (mpp_frame_get_info_change(mppframe)) {
-            AVHWFramesContext *hwframes;
+    if (!mppframe) {
+        av_log(avctx, AV_LOG_DEBUG, "Timeout getting decoded frame.\n");
+        return AVERROR(EAGAIN);
+    }
 
-            av_log(avctx, AV_LOG_INFO, "Decoder noticed an info change (%dx%d), format=%d\n",
-                                        (int)mpp_frame_get_width(mppframe), (int)mpp_frame_get_height(mppframe),
-                                        (int)mpp_frame_get_fmt(mppframe));
+    if (mpp_frame_get_eos(mppframe)) {
+        av_log(avctx, AV_LOG_DEBUG, "Received a EOS frame.\n");
+        decoder->eos = 1;
+        ret = AVERROR_EOF;
+        goto fail;
+    }
 
-            avctx->width = mpp_frame_get_width(mppframe);
-            avctx->height = mpp_frame_get_height(mppframe);
+    if (mpp_frame_get_discard(mppframe)) {
+        av_log(avctx, AV_LOG_DEBUG, "Received a discard frame.\n");
+        ret = AVERROR(EAGAIN);
+        goto fail;
+    }
 
-            decoder->mpi->control(decoder->ctx, MPP_DEC_SET_INFO_CHANGE_READY, NULL);
+    if (mpp_frame_get_errinfo(mppframe)) {
+        av_log(avctx, AV_LOG_ERROR, "Received a errinfo frame.\n");
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
 
-            av_buffer_unref(&decoder->frames_ref);
+    if (mpp_frame_get_info_change(mppframe)) {
+        AVHWFramesContext *hwframes;
 
-            decoder->frames_ref = av_hwframe_ctx_alloc(decoder->device_ref);
-            if (!decoder->frames_ref) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
+        av_log(avctx, AV_LOG_INFO, "Decoder noticed an info change (%dx%d), format=%d\n",
+               (int)mpp_frame_get_width(mppframe), (int)mpp_frame_get_height(mppframe),
+               (int)mpp_frame_get_fmt(mppframe));
 
-            mppformat = mpp_frame_get_fmt(mppframe);
-            drmformat = rkmpp_get_frameformat(mppformat);
+        avctx->width = mpp_frame_get_width(mppframe);
+        avctx->height = mpp_frame_get_height(mppframe);
 
-            hwframes = (AVHWFramesContext*)decoder->frames_ref->data;
-            hwframes->format    = AV_PIX_FMT_DRM_PRIME;
-            hwframes->sw_format = drmformat == DRM_FORMAT_NV12 ? AV_PIX_FMT_NV12 : AV_PIX_FMT_NONE;
-            hwframes->width     = avctx->width;
-            hwframes->height    = avctx->height;
-            ret = av_hwframe_ctx_init(decoder->frames_ref);
-            if (ret < 0)
-                goto fail;
+        decoder->mpi->control(decoder->ctx, MPP_DEC_SET_FRAME_INFO, (MppParam) mppframe);
+        decoder->mpi->control(decoder->ctx, MPP_DEC_SET_INFO_CHANGE_READY, NULL);
 
-            // here decoder is fully initialized, we need to feed it again with data
-            ret = AVERROR(EAGAIN);
-            goto fail;
-        } else if (mpp_frame_get_eos(mppframe)) {
-            av_log(avctx, AV_LOG_DEBUG, "Received a EOS frame.\n");
-            decoder->eos_reached = 1;
-            ret = AVERROR_EOF;
-            goto fail;
-        } else if (mpp_frame_get_discard(mppframe)) {
-            av_log(avctx, AV_LOG_DEBUG, "Received a discard frame.\n");
-            ret = AVERROR(EAGAIN);
-            goto fail;
-        } else if (mpp_frame_get_errinfo(mppframe)) {
-            av_log(avctx, AV_LOG_ERROR, "Received a errinfo frame.\n");
-            ret = AVERROR_UNKNOWN;
+        av_buffer_unref(&decoder->frames_ref);
+
+        decoder->frames_ref = av_hwframe_ctx_alloc(decoder->device_ref);
+        if (!decoder->frames_ref) {
+            ret = AVERROR(ENOMEM);
             goto fail;
         }
 
-        // here we should have a valid frame
-        av_log(avctx, AV_LOG_DEBUG, "Received a frame.\n");
+        mppformat = mpp_frame_get_fmt(mppframe);
+        drmformat = rkmpp_get_frameformat(mppformat);
 
-        // setup general frame fields
-        frame->format           = AV_PIX_FMT_DRM_PRIME;
-        frame->width            = mpp_frame_get_width(mppframe);
-        frame->height           = mpp_frame_get_height(mppframe);
-        frame->pts              = mpp_frame_get_pts(mppframe);
-        frame->reordered_opaque = frame->pts;
-        frame->color_range      = mpp_frame_get_color_range(mppframe);
-        frame->color_primaries  = mpp_frame_get_color_primaries(mppframe);
-        frame->color_trc        = mpp_frame_get_color_trc(mppframe);
-        frame->colorspace       = mpp_frame_get_colorspace(mppframe);
+        hwframes = (AVHWFramesContext*)decoder->frames_ref->data;
+        hwframes->format    = AV_PIX_FMT_DRM_PRIME;
+        hwframes->sw_format = drmformat == DRM_FORMAT_NV12 ? AV_PIX_FMT_NV12 : AV_PIX_FMT_NONE;
+        hwframes->width     = avctx->width;
+        hwframes->height    = avctx->height;
+        ret = av_hwframe_ctx_init(decoder->frames_ref);
+        if (!ret)
+            ret = AVERROR(EAGAIN);
 
-        mode = mpp_frame_get_mode(mppframe);
-        frame->interlaced_frame = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_DEINTERLACED);
-        frame->top_field_first  = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST);
+        goto fail;
+    }
 
-        mppformat = mpp_frame_get_fmt(mppframe);
-        drmformat = rkmpp_get_frameformat(mppformat);
+    // here we should have a valid frame
+    av_log(avctx, AV_LOG_DEBUG, "Received a frame.\n");
 
-        // now setup the frame buffer info
-        buffer = mpp_frame_get_buffer(mppframe);
-        if (buffer) {
-            desc = av_mallocz(sizeof(AVDRMFrameDescriptor));
-            if (!desc) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
+    // now setup the frame buffer info
+    buffer = mpp_frame_get_buffer(mppframe);
+    if (!buffer) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to get the frame buffer, frame is dropped (code = %d)\n", ret);
+        ret = AVERROR(EAGAIN);
+        goto fail;
+    }
 
-            desc->nb_objects = 1;
-            desc->objects[0].fd = mpp_buffer_get_fd(buffer);
-            desc->objects[0].size = mpp_buffer_get_size(buffer);
-
-            desc->nb_layers = 1;
-            layer = &desc->layers[0];
-            layer->format = drmformat;
-            layer->nb_planes = 2;
-
-            layer->planes[0].object_index = 0;
-            layer->planes[0].offset = 0;
-            layer->planes[0].pitch = mpp_frame_get_hor_stride(mppframe);
-
-            layer->planes[1].object_index = 0;
-            layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mppframe);
-            layer->planes[1].pitch = layer->planes[0].pitch;
-
-            // we also allocate a struct in buf[0] that will allow to hold additionnal information
-            // for releasing properly MPP frames and decoder
-            framecontextref = av_buffer_allocz(sizeof(*framecontext));
-            if (!framecontextref) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
+    // setup general frame fields
+    frame->format           = avctx->pix_fmt;
+    frame->width            = mpp_frame_get_width(mppframe);
+    frame->height           = mpp_frame_get_height(mppframe);
+    frame->pts              = mpp_frame_get_pts(mppframe);
+    frame->reordered_opaque = frame->pts;
+    frame->color_range      = mpp_frame_get_color_range(mppframe);
+    frame->color_primaries  = mpp_frame_get_color_primaries(mppframe);
+    frame->color_trc        = mpp_frame_get_color_trc(mppframe);
+    frame->colorspace       = mpp_frame_get_colorspace(mppframe);
+
+    mode = mpp_frame_get_mode(mppframe);
+    frame->interlaced_frame = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_DEINTERLACED);
+    frame->top_field_first  = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST);
+
+    mppformat = mpp_frame_get_fmt(mppframe);
+    drmformat = rkmpp_get_frameformat(mppformat);
+
+    desc = av_mallocz(sizeof(AVDRMFrameDescriptor));
+    if (!desc) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
 
-            // MPP decoder needs to be closed only when all frames have been released.
-            framecontext = (RKMPPFrameContext *)framecontextref->data;
-            framecontext->decoder_ref = av_buffer_ref(rk_context->decoder_ref);
-            framecontext->frame = mppframe;
+    desc->nb_objects = 1;
+    desc->objects[0].fd = mpp_buffer_get_fd(buffer);
+    desc->objects[0].size = mpp_buffer_get_size(buffer);
 
-            frame->data[0]  = (uint8_t *)desc;
-            frame->buf[0]   = av_buffer_create((uint8_t *)desc, sizeof(*desc), rkmpp_release_frame,
-                                               framecontextref, AV_BUFFER_FLAG_READONLY);
+    desc->nb_layers = 1;
+    layer = &desc->layers[0];
+    layer->format = drmformat;
+    layer->nb_planes = 2;
 
-            if (!frame->buf[0]) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
+    layer->planes[0].object_index = 0;
+    layer->planes[0].offset = 0;
+    layer->planes[0].pitch = mpp_frame_get_hor_stride(mppframe);
 
-            frame->hw_frames_ctx = av_buffer_ref(decoder->frames_ref);
-            if (!frame->hw_frames_ctx) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
+    layer->planes[1].object_index = 0;
+    layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mppframe);
+    layer->planes[1].pitch = layer->planes[0].pitch;
 
-            return 0;
-        } else {
-            av_log(avctx, AV_LOG_ERROR, "Failed to retrieve the frame buffer, frame is dropped (code = %d)\n", ret);
-            mpp_frame_deinit(&mppframe);
-        }
-    } else if (decoder->eos_reached) {
-        return AVERROR_EOF;
-    } else if (ret == MPP_ERR_TIMEOUT) {
-        av_log(avctx, AV_LOG_DEBUG, "Timeout when trying to get a frame from MPP\n");
+    // we also allocate a struct in buf[0] that will allow to hold additionnal information
+    // for releasing properly MPP frames and decoder
+    framecontextref = av_buffer_allocz(sizeof(*framecontext));
+    if (!framecontextref) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
     }
 
-    return AVERROR(EAGAIN);
+    // MPP decoder needs to be closed only when all frames have been released.
+    framecontext = (RKMPPFrameContext *)framecontextref->data;
+    framecontext->decoder_ref = av_buffer_ref(rk_context->decoder_ref);
+    framecontext->frame = mppframe;
+
+    frame->data[0]  = (uint8_t *)desc;
+    frame->buf[0]   = av_buffer_create((uint8_t *)desc, sizeof(*desc), rkmpp_release_frame,
+                                       framecontextref, AV_BUFFER_FLAG_READONLY);
+
+    if (!frame->buf[0]) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    frame->hw_frames_ctx = av_buffer_ref(decoder->frames_ref);
+    if (!frame->hw_frames_ctx) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    return 0;
 
 fail:
     if (mppframe)
@@ -489,60 +433,130 @@ fail:
     return ret;
 }
 
+static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *packet)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    MppPacket mpkt;
+    int64_t pts = packet->pts;
+    int ret;
+
+    // avoid sending new data after EOS
+    if (decoder->draining)
+        return AVERROR_EOF;
+
+    if (!pts || pts == AV_NOPTS_VALUE)
+        pts = avctx->reordered_opaque;
+
+    ret = mpp_packet_init(&mpkt, packet->data, packet->size);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init MPP packet (code = %d)\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    mpp_packet_set_pts(mpkt, pts);
+
+    ret = decoder->mpi->decode_put_packet(decoder->ctx, mpkt);
+    mpp_packet_deinit(&mpkt);
+
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_DEBUG, "Buffer full\n");
+        return AVERROR(EAGAIN);
+    }
+
+    av_log(avctx, AV_LOG_DEBUG, "Wrote %d bytes to decoder\n", packet->size);
+    return 0;
+}
+
+static int rkmpp_send_eos(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    MppPacket mpkt;
+    int ret;
+
+    ret = mpp_packet_init(&mpkt, NULL, 0);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init EOS packet (code = %d)\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    mpp_packet_set_eos(mpkt);
+
+    do {
+        ret = decoder->mpi->decode_put_packet(decoder->ctx, mpkt);
+    } while (ret != MPP_OK);
+    mpp_packet_deinit(&mpkt);
+
+    decoder->draining = 1;
+
+    return 0;
+}
+
 static int rkmpp_receive_frame(AVCodecContext *avctx, AVFrame *frame)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
     RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret = MPP_NOK;
-    AVPacket pkt = {0};
-    RK_S32 usedslots, freeslots;
-
-    if (!decoder->eos_reached) {
-        // we get the available slots in decoder
-        ret = decoder->mpi->control(decoder->ctx, MPP_DEC_GET_STREAM_COUNT, &usedslots);
-        if (ret != MPP_OK) {
-            av_log(avctx, AV_LOG_ERROR, "Failed to get decoder used slots (code = %d).\n", ret);
-            return ret;
-        }
+    AVPacket *packet = &decoder->packet;
+    int ret;
 
-        freeslots = INPUT_MAX_PACKETS - usedslots;
-        if (freeslots > 0) {
-            ret = ff_decode_get_packet(avctx, &pkt);
-            if (ret < 0 && ret != AVERROR_EOF) {
+    // no more frames after EOS
+    if (decoder->eos)
+        return AVERROR_EOF;
+
+    // draining remain frames
+    if (decoder->draining)
+        return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
+
+    while (1) {
+        if (!packet->size) {
+            ret = ff_decode_get_packet(avctx, packet);
+            if (ret == AVERROR_EOF) {
+                av_log(avctx, AV_LOG_DEBUG, "End of stream.\n");
+                // send EOS and start draining
+                rkmpp_send_eos(avctx);
+                return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
+            } else if (ret == AVERROR(EAGAIN)) {
+                // not blocking so that we can feed new data ASAP
+                return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_NON_BLOCK);
+            } else if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "Failed to get packet (code = %d)\n", ret);
                 return ret;
             }
-
-            ret = rkmpp_send_packet(avctx, &pkt);
-            av_packet_unref(&pkt);
-
-            if (ret < 0) {
-                av_log(avctx, AV_LOG_ERROR, "Failed to send packet to decoder (code = %d)\n", ret);
+        } else {
+            // send pending data to decoder
+            ret = rkmpp_send_packet(avctx, packet);
+            if (ret == AVERROR(EAGAIN)) {
+                // some streams might need more packets to start returning frames
+                ret = rkmpp_get_frame(avctx, frame, 1);
+                if (ret != AVERROR(EAGAIN))
+                    return ret;
+            } else if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "Failed to send data (code = %d)\n", ret);
                 return ret;
+            } else {
+                av_packet_unref(packet);
+                packet->size = 0;
             }
         }
-
-        // make sure we keep decoder full
-        if (freeslots > 1)
-            return AVERROR(EAGAIN);
     }
-
-    return rkmpp_retrieve_frame(avctx, frame);
 }
 
 static void rkmpp_flush(AVCodecContext *avctx)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
     RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret = MPP_NOK;
 
     av_log(avctx, AV_LOG_DEBUG, "Flush.\n");
 
-    ret = decoder->mpi->reset(decoder->ctx);
-    if (ret == MPP_OK) {
-        decoder->first_packet = 1;
-        decoder->eos_reached = 0;
-    } else
-        av_log(avctx, AV_LOG_ERROR, "Failed to reset MPI (code = %d)\n", ret);
+    decoder->mpi->reset(decoder->ctx);
+
+    rkmpp_prepare_decoder(avctx);
+
+    decoder->eos = 0;
+    decoder->draining = 0;
+
+    av_packet_unref(&decoder->packet);
 }
 
 static const AVCodecHWConfigInternal *const rkmpp_hw_configs[] = {
-- 
2.40.0


From 3f3e229c729d779ff1b4bc6ec8abc11e2b2b078b Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Fri, 21 May 2021 04:23:36 +0800
Subject: [PATCH 05/24] HACK: avcodec/rkmppdec: Force aligning coded width and
 height to 64

The chromium would try to align planes' width and height to 32, which
might break the plane buffers' contiguous required by RGA.

Passing a 64-aligned coded width and height to avoid that.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libavcodec/rkmppdec.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index d3c13297d2..c767fc8f1b 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -309,6 +309,11 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
         avctx->width = mpp_frame_get_width(mppframe);
         avctx->height = mpp_frame_get_height(mppframe);
 
+        // chromium would align planes' width and height to 32, adding this
+        // hack to avoid breaking the plane buffers' contiguous.
+        avctx->coded_width = FFALIGN(avctx->width, 64);
+        avctx->coded_height = FFALIGN(avctx->height, 64);
+
         decoder->mpi->control(decoder->ctx, MPP_DEC_SET_FRAME_INFO, (MppParam) mppframe);
         decoder->mpi->control(decoder->ctx, MPP_DEC_SET_INFO_CHANGE_READY, NULL);
 
-- 
2.40.0


From fdf094ef3e983706e28f7f77d96284de554612d9 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Thu, 20 May 2021 10:20:17 +0800
Subject: [PATCH 06/24] HACK: avcodec/rkmppdec: Support outputing YUV420P

Lots of users support YUV420P format rather than DRM_PRIME.

Support RGA accelerated format conversion.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 configure             |   7 ++-
 libavcodec/rkmppdec.c | 121 +++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 126 insertions(+), 2 deletions(-)

diff --git a/configure b/configure
index b6616f00b6..b2b6d45e78 100755
--- a/configure
+++ b/configure
@@ -349,6 +349,7 @@ External library support:
   --enable-omx             enable OpenMAX IL code [no]
   --enable-omx-rpi         enable OpenMAX IL code for Raspberry Pi [no]
   --enable-rkmpp           enable Rockchip Media Process Platform code [no]
+  --enable-librga          enable Rockchip RGA 2D accel via librga [autodetect]
   --disable-v4l2-m2m       disable V4L2 mem2mem code [autodetect]
   --disable-vaapi          disable Video Acceleration API (mainly Unix/Intel) code [autodetect]
   --disable-vdpau          disable Nvidia Video Decode and Presentation API for Unix code [autodetect]
@@ -1892,6 +1893,7 @@ HWACCEL_AUTODETECT_LIBRARY_LIST="
     videotoolbox
     vulkan
     v4l2_m2m
+    librga
 "
 
 # catchall list of things that require external libs to link
@@ -6789,10 +6791,13 @@ enabled openssl           && { { check_pkg_config openssl "openssl >= 3.0.0" ope
                                check_lib openssl openssl/ssl.h SSL_library_init -lssl -lcrypto -lws2_32 -lgdi32 ||
                                die "ERROR: openssl not found"; }
 enabled pocketsphinx      && require_pkg_config pocketsphinx pocketsphinx pocketsphinx/pocketsphinx.h ps_init
+enabled librga            && check_lib librga rga/RgaApi.h c_RkRgaInit -lrga && prepend rkmpp_deps "librga"
 enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp  rockchip/rk_mpi.h mpp_create &&
                                require_pkg_config rockchip_mpp "rockchip_mpp >= 1.3.7" rockchip/rk_mpi.h mpp_create &&
                                { enabled libdrm ||
-                                 die "ERROR: rkmpp requires --enable-libdrm"; }
+                                 die "ERROR: rkmpp requires --enable-libdrm"; } &&
+                               { enabled librga ||
+                                 warn "using rkmpp without librga"; }
                              }
 enabled vapoursynth       && require_pkg_config vapoursynth "vapoursynth-script >= 42" VSScript.h vsscript_init
 
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index c767fc8f1b..2bcc357c36 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -28,6 +28,7 @@
 
 #include "avcodec.h"
 #include "codec_internal.h"
+#include "internal.h"
 #include "decode.h"
 #include "hwconfig.h"
 #include "libavutil/buffer.h"
@@ -38,6 +39,11 @@
 #include "libavutil/imgutils.h"
 #include "libavutil/log.h"
 
+#if CONFIG_LIBRGA
+#include <rga/rga.h>
+#include <rga/RgaApi.h>
+#endif
+
 typedef struct {
     MppCtx ctx;
     MppApi *mpi;
@@ -83,6 +89,17 @@ static uint32_t rkmpp_get_frameformat(MppFrameFormat mppformat)
     }
 }
 
+#if CONFIG_LIBRGA
+static uint32_t rkmpp_get_rgaformat(MppFrameFormat mppformat)
+{
+    switch (mppformat) {
+    case MPP_FMT_YUV420SP:          return RK_FORMAT_YCbCr_420_SP;
+    case MPP_FMT_YUV420SP_10BIT:    return RK_FORMAT_YCbCr_420_SP_10B;
+    default:                        return RK_FORMAT_UNKNOWN;
+    }
+}
+#endif
+
 static int rkmpp_close_decoder(AVCodecContext *avctx)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
@@ -142,7 +159,7 @@ static int rkmpp_init_decoder(AVCodecContext *avctx)
     MppCodingType codectype = MPP_VIDEO_CodingUnused;
     int ret;
 
-    avctx->pix_fmt = AV_PIX_FMT_DRM_PRIME;
+    avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);
 
     // create a decoder and a ref to it
     decoder = av_mallocz(sizeof(RKMPPDecoder));
@@ -248,6 +265,95 @@ static void rkmpp_release_frame(void *opaque, uint8_t *data)
     av_free(desc);
 }
 
+static int rkmpp_convert_frame(AVCodecContext *avctx, AVFrame *frame,
+                               MppFrame mppframe, MppBuffer buffer)
+{
+    char *src = mpp_buffer_get_ptr(buffer);
+    char *dst_y = frame->data[0];
+    char *dst_u = frame->data[1];
+    char *dst_v = frame->data[2];
+#if CONFIG_LIBRGA
+    RgaSURF_FORMAT format = rkmpp_get_rgaformat(mpp_frame_get_fmt(mppframe));
+#endif
+    int width = mpp_frame_get_width(mppframe);
+    int height = mpp_frame_get_height(mppframe);
+    int hstride = mpp_frame_get_hor_stride(mppframe);
+    int vstride = mpp_frame_get_ver_stride(mppframe);
+    int y_pitch = frame->linesize[0];
+    int u_pitch = frame->linesize[1];
+    int v_pitch = frame->linesize[2];
+    int i, j;
+
+#if CONFIG_LIBRGA
+    rga_info_t src_info = {0};
+    rga_info_t dst_info = {0};
+    int dst_height = (dst_u - dst_y) / y_pitch;
+
+    static int rga_supported = 1;
+    static int rga_inited = 0;
+
+    if (!rga_supported)
+        goto bail;
+
+    if (!rga_inited) {
+        if (c_RkRgaInit() < 0) {
+            rga_supported = 0;
+            av_log(avctx, AV_LOG_WARNING, "RGA not available\n");
+            goto bail;
+        }
+        rga_inited = 1;
+    }
+
+    if (format == RK_FORMAT_UNKNOWN)
+        goto bail;
+
+    if (u_pitch != y_pitch / 2 || v_pitch != y_pitch / 2 ||
+        dst_u != dst_y + y_pitch * dst_height ||
+        dst_v != dst_u + u_pitch * dst_height / 2)
+        goto bail;
+
+    src_info.fd = mpp_buffer_get_fd(buffer);
+    src_info.mmuFlag = 1;
+    rga_set_rect(&src_info.rect, 0, 0, width, height, hstride, vstride,
+                 format);
+
+    dst_info.virAddr = dst_y;
+    dst_info.mmuFlag = 1;
+    rga_set_rect(&dst_info.rect, 0, 0, frame->width, frame->height,
+                 y_pitch, dst_height, RK_FORMAT_YCbCr_420_P);
+
+    if (c_RkRgaBlit(&src_info, &dst_info, NULL) < 0)
+        goto bail;
+
+    return 0;
+
+bail:
+#endif
+    if (mpp_frame_get_fmt(mppframe) != MPP_FMT_YUV420SP) {
+        av_log(avctx, AV_LOG_WARNING, "Unable to convert\n");
+        return -1;
+    }
+
+    av_log(avctx, AV_LOG_WARNING, "Doing slow software conversion\n");
+
+    for (i = 0; i < frame->height; i++)
+        memcpy(dst_y + i * y_pitch, src + i * hstride, frame->width);
+
+    src += hstride * vstride;
+
+    for (i = 0; i < frame->height / 2; i++) {
+        for (j = 0; j < frame->width; j++) {
+            dst_u[j] = src[2 * j + 0];
+            dst_v[j] = src[2 * j + 1];
+        }
+        dst_u += u_pitch;
+        dst_v += v_pitch;
+        src += hstride;
+    }
+
+    return 0;
+}
+
 static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
@@ -355,6 +461,16 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     frame->format           = avctx->pix_fmt;
     frame->width            = mpp_frame_get_width(mppframe);
     frame->height           = mpp_frame_get_height(mppframe);
+
+    if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME) {
+        ret = ff_get_buffer(avctx, frame, 0);
+        if (ret < 0)
+            goto out;
+
+        ret = rkmpp_convert_frame(avctx, frame, mppframe, buffer);
+        goto out;
+    }
+
     frame->pts              = mpp_frame_get_pts(mppframe);
     frame->reordered_opaque = frame->pts;
     frame->color_range      = mpp_frame_get_color_range(mppframe);
@@ -422,6 +538,7 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
 
     return 0;
 
+out:
 fail:
     if (mppframe)
         mpp_frame_deinit(&mppframe);
@@ -566,6 +683,7 @@ static void rkmpp_flush(AVCodecContext *avctx)
 
 static const AVCodecHWConfigInternal *const rkmpp_hw_configs[] = {
     HW_CONFIG_INTERNAL(DRM_PRIME),
+    HW_CONFIG_INTERNAL(YUV420P),
     NULL
 };
 
@@ -590,6 +708,7 @@ static const AVCodecHWConfigInternal *const rkmpp_hw_configs[] = {
         .p.priv_class   = &rkmpp_##NAME##_dec_class, \
         .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE, \
         .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_DRM_PRIME, \
+                                                         AV_PIX_FMT_YUV420P, \
                                                          AV_PIX_FMT_NONE}, \
         .hw_configs     = rkmpp_hw_configs, \
         .bsfs           = BSFS, \
-- 
2.40.0


From 6f54c9ff2d603000d3ee112c584b4d76a23bfd5f Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Mon, 27 Sep 2021 10:20:54 +0800
Subject: [PATCH 07/24] avcodec/rkmppdec: Support logging fps

Set env FFMPEG_RKMPP_LOG_FPS=1 to enable it.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libavcodec/rkmppdec.c | 46 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 46 insertions(+)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 2bcc357c36..41e17422a0 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -25,6 +25,7 @@
 #include <rockchip/rk_mpi.h>
 #include <time.h>
 #include <unistd.h>
+#include <sys/time.h>
 
 #include "avcodec.h"
 #include "codec_internal.h"
@@ -44,6 +45,8 @@
 #include <rga/RgaApi.h>
 #endif
 
+#define FPS_UPDATE_INTERVAL     120
+
 typedef struct {
     MppCtx ctx;
     MppApi *mpi;
@@ -55,6 +58,11 @@ typedef struct {
     AVPacket packet;
     AVBufferRef *frames_ref;
     AVBufferRef *device_ref;
+
+    char print_fps;
+
+    uint64_t last_fps_time;
+    uint64_t frames;
 } RKMPPDecoder;
 
 typedef struct {
@@ -157,6 +165,7 @@ static int rkmpp_init_decoder(AVCodecContext *avctx)
     RKMPPDecodeContext *rk_context = avctx->priv_data;
     RKMPPDecoder *decoder = NULL;
     MppCodingType codectype = MPP_VIDEO_CodingUnused;
+    char *env;
     int ret;
 
     avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);
@@ -168,6 +177,10 @@ static int rkmpp_init_decoder(AVCodecContext *avctx)
         goto fail;
     }
 
+    env = getenv("FFMPEG_RKMPP_LOG_FPS");
+    if (env != NULL)
+        decoder->print_fps = !!atoi(env);
+
     rk_context->decoder_ref = av_buffer_create((uint8_t *)decoder, sizeof(*decoder), rkmpp_release_decoder,
                                                NULL, AV_BUFFER_FLAG_READONLY);
     if (!rk_context->decoder_ref) {
@@ -354,6 +367,36 @@ bail:
     return 0;
 }
 
+static void rkmpp_update_fps(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    struct timeval tv;
+    uint64_t curr_time;
+    float fps;
+
+    if (!decoder->print_fps)
+        return;
+
+    if (!decoder->last_fps_time) {
+        gettimeofday(&tv, NULL);
+        decoder->last_fps_time = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+    }
+
+    if (++decoder->frames % FPS_UPDATE_INTERVAL)
+        return;
+
+    gettimeofday(&tv, NULL);
+    curr_time = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+
+    fps = 1000.0f * FPS_UPDATE_INTERVAL / (curr_time - decoder->last_fps_time);
+    decoder->last_fps_time = curr_time;
+
+    av_log(avctx, AV_LOG_INFO,
+           "[FFMPEG RKMPP] FPS: %6.1f || Frames: %" PRIu64 "\n",
+           fps, decoder->frames);
+}
+
 static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
@@ -457,6 +500,8 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
         goto fail;
     }
 
+    rkmpp_update_fps(avctx);
+
     // setup general frame fields
     frame->format           = avctx->pix_fmt;
     frame->width            = mpp_frame_get_width(mppframe);
@@ -677,6 +722,7 @@ static void rkmpp_flush(AVCodecContext *avctx)
 
     decoder->eos = 0;
     decoder->draining = 0;
+    decoder->last_fps_time = decoder->frames = 0;
 
     av_packet_unref(&decoder->packet);
 }
-- 
2.40.0


From 8b3fb18571d3dcf1f561f413c07aec7412046ea7 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Mon, 27 Sep 2021 11:06:11 +0800
Subject: [PATCH 08/24] HACK: libavcodec & rkmppdec: Add
 FF_CODEC_CAP_CONTIGUOUS_BUFFERS

Add FF_CODEC_CAP_CONTIGUOUS_BUFFERS to alloc contiguous buffers.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libavcodec/codec_internal.h |  4 ++++
 libavcodec/get_buffer.c     | 24 ++++++++++++++++++++++++
 libavcodec/rkmppdec.c       | 19 ++++++++++---------
 3 files changed, 38 insertions(+), 9 deletions(-)

diff --git a/libavcodec/codec_internal.h b/libavcodec/codec_internal.h
index 130a7dc3cd..ed0dea86de 100644
--- a/libavcodec/codec_internal.h
+++ b/libavcodec/codec_internal.h
@@ -80,6 +80,10 @@
  * Codec supports embedded ICC profiles (AV_FRAME_DATA_ICC_PROFILE).
  */
 #define FF_CODEC_CAP_ICC_PROFILES           (1 << 9)
+/**
+ * The decoder requires contiguous buffers.
+ */
+#define FF_CODEC_CAP_CONTIGUOUS_BUFFERS     (1 << 28)
 /**
  * The encoder has AV_CODEC_CAP_DELAY set, but does not actually have delay - it
  * only wants to be flushed at the end to update some context variables (e.g.
diff --git a/libavcodec/get_buffer.c b/libavcodec/get_buffer.c
index a04fd878de..c6a1983f7e 100644
--- a/libavcodec/get_buffer.c
+++ b/libavcodec/get_buffer.c
@@ -32,6 +32,7 @@
 
 #include "avcodec.h"
 #include "internal.h"
+#include "codec_internal.h"
 
 typedef struct FramePool {
     /**
@@ -147,6 +148,14 @@ FF_ENABLE_DEPRECATION_WARNINGS
 
         for (i = 0; i < 4; i++) {
             pool->linesize[i] = linesize[i];
+
+            if (ffcodec(avctx->codec)->caps_internal & FF_CODEC_CAP_CONTIGUOUS_BUFFERS) {
+                if (!i)
+                    size[0] += size[1] + size[2] + size[3];
+                else
+                    continue;
+            }
+
             if (size[i]) {
                 if (size[i] > INT_MAX - (16 + STRIDE_ALIGN - 1)) {
                     ret = AVERROR(EINVAL);
@@ -265,6 +274,21 @@ static int video_get_buffer(AVCodecContext *s, AVFrame *pic)
 
         pic->data[i] = pic->buf[i]->data;
     }
+
+    if (ffcodec(s->codec)->caps_internal & FF_CODEC_CAP_CONTIGUOUS_BUFFERS) {
+        int size;
+
+        for (i = 1; i < 4; i++) {
+            pic->linesize[i] = pool->linesize[i];
+            av_buffer_unref(&pic->buf[i]);
+        }
+
+        size = av_image_fill_pointers(pic->data, pic->format, pic->height,
+                                      pic->buf[0]->data, pic->linesize);
+        if (size < 0 || size > pic->buf[0]->size)
+            goto fail;
+    }
+
     for (; i < AV_NUM_DATA_POINTERS; i++) {
         pic->data[i] = NULL;
         pic->linesize[i] = 0;
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 41e17422a0..01ab7e5492 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -502,20 +502,16 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
 
     rkmpp_update_fps(avctx);
 
-    // setup general frame fields
-    frame->format           = avctx->pix_fmt;
-    frame->width            = mpp_frame_get_width(mppframe);
-    frame->height           = mpp_frame_get_height(mppframe);
-
     if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME) {
         ret = ff_get_buffer(avctx, frame, 0);
         if (ret < 0)
             goto out;
-
-        ret = rkmpp_convert_frame(avctx, frame, mppframe, buffer);
-        goto out;
     }
 
+    // setup general frame fields
+    frame->format           = avctx->pix_fmt;
+    frame->width            = mpp_frame_get_width(mppframe);
+    frame->height           = mpp_frame_get_height(mppframe);
     frame->pts              = mpp_frame_get_pts(mppframe);
     frame->reordered_opaque = frame->pts;
     frame->color_range      = mpp_frame_get_color_range(mppframe);
@@ -527,6 +523,11 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     frame->interlaced_frame = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_DEINTERLACED);
     frame->top_field_first  = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST);
 
+    if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME) {
+        ret = rkmpp_convert_frame(avctx, frame, mppframe, buffer);
+        goto out;
+    }
+
     mppformat = mpp_frame_get_fmt(mppframe);
     drmformat = rkmpp_get_frameformat(mppformat);
 
@@ -759,7 +760,7 @@ static const AVCodecHWConfigInternal *const rkmpp_hw_configs[] = {
         .hw_configs     = rkmpp_hw_configs, \
         .bsfs           = BSFS, \
         .p.wrapper_name = "rkmpp", \
-        .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE, \
+        .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE | FF_CODEC_CAP_CONTIGUOUS_BUFFERS \
     };
 
 RKMPP_DEC(h264,  AV_CODEC_ID_H264,          "h264_mp4toannexb")
-- 
2.40.0


From 8e916a6896d847d4cda4d455ad47e188c1825337 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Mon, 13 Dec 2021 15:44:43 +0800
Subject: [PATCH 09/24] HACK: avcodec/rkmppdec: Support NV15

NV15 is the official DRM fourcc for Arm's NV12 10LE40 format.

Fallback to NA12 for older Rockchip BSP kernel.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libavcodec/rkmppdec.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 01ab7e5492..403f5339a9 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -45,6 +45,11 @@
 #include <rga/RgaApi.h>
 #endif
 
+// HACK: Older BSP kernel use NA12 for NV15.
+#ifndef DRM_FORMAT_NV15 // fourcc_code('N', 'V', '1', '5')
+#define DRM_FORMAT_NV15 fourcc_code('N', 'A', '1', '2')
+#endif
+
 #define FPS_UPDATE_INTERVAL     120
 
 typedef struct {
@@ -90,9 +95,7 @@ static uint32_t rkmpp_get_frameformat(MppFrameFormat mppformat)
 {
     switch (mppformat) {
     case MPP_FMT_YUV420SP:          return DRM_FORMAT_NV12;
-#ifdef DRM_FORMAT_NV12_10
-    case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_NV12_10;
-#endif
+    case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_NV15;
     default:                        return 0;
     }
 }
-- 
2.40.0


From c9d8ec349c5b766dffafbddbe3b1ef0e57b24456 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Wed, 15 Dec 2021 15:34:48 +0800
Subject: [PATCH 10/24] avcodec/rkmppdec: Support NV16

The MPP might output NV16 format.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libavcodec/rkmppdec.c | 15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 403f5339a9..770c4ef71c 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -96,6 +96,17 @@ static uint32_t rkmpp_get_frameformat(MppFrameFormat mppformat)
     switch (mppformat) {
     case MPP_FMT_YUV420SP:          return DRM_FORMAT_NV12;
     case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_NV15;
+    case MPP_FMT_YUV422SP:          return DRM_FORMAT_NV16;
+    default:                        return 0;
+    }
+}
+
+static uint32_t rkmpp_get_avformat(MppFrameFormat mppformat)
+{
+    switch (mppformat) {
+    case MPP_FMT_YUV420SP:          return AV_PIX_FMT_NV12;
+    case MPP_FMT_YUV420SP_10BIT:    return AV_PIX_FMT_NONE;
+    case MPP_FMT_YUV422SP:          return AV_PIX_FMT_NV16;
     default:                        return 0;
     }
 }
@@ -106,6 +117,7 @@ static uint32_t rkmpp_get_rgaformat(MppFrameFormat mppformat)
     switch (mppformat) {
     case MPP_FMT_YUV420SP:          return RK_FORMAT_YCbCr_420_SP;
     case MPP_FMT_YUV420SP_10BIT:    return RK_FORMAT_YCbCr_420_SP_10B;
+    case MPP_FMT_YUV422SP:          return RK_FORMAT_YCbCr_422_SP;
     default:                        return RK_FORMAT_UNKNOWN;
     }
 }
@@ -478,11 +490,10 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
         }
 
         mppformat = mpp_frame_get_fmt(mppframe);
-        drmformat = rkmpp_get_frameformat(mppformat);
 
         hwframes = (AVHWFramesContext*)decoder->frames_ref->data;
         hwframes->format    = AV_PIX_FMT_DRM_PRIME;
-        hwframes->sw_format = drmformat == DRM_FORMAT_NV12 ? AV_PIX_FMT_NV12 : AV_PIX_FMT_NONE;
+        hwframes->sw_format = rkmpp_get_avformat(mppformat);
         hwframes->width     = avctx->width;
         hwframes->height    = avctx->height;
         ret = av_hwframe_ctx_init(decoder->frames_ref);
-- 
2.40.0


From 06e79e58f08c7426681497aa1f653ba1cc116947 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Wed, 23 Mar 2022 14:20:16 +0800
Subject: [PATCH 11/24] avcodec/rkmppdec: Support sync mode

Some people just don't know how to handle async APIs :(

Support sync mode by waiting for decode result after feeding any packets.

Set env "FFMPEG_RKMPP_SYNC" to enable it.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libavcodec/rkmppdec.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 770c4ef71c..9539a48817 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -68,6 +68,8 @@ typedef struct {
 
     uint64_t last_fps_time;
     uint64_t frames;
+
+    char sync;
 } RKMPPDecoder;
 
 typedef struct {
@@ -172,6 +174,13 @@ static int rkmpp_prepare_decoder(AVCodecContext *avctx)
         if (ret < 0)
             return AVERROR_UNKNOWN;
     }
+
+    if (getenv("FFMPEG_RKMPP_SYNC")) {
+        // wait for decode result after feeding any packets
+        decoder->sync = 1;
+        ret = 1;
+        decoder->mpi->control(decoder->ctx, MPP_DEC_SET_IMMEDIATE_OUT, &ret);
+    }
     return 0;
 }
 
@@ -719,6 +728,10 @@ static int rkmpp_receive_frame(AVCodecContext *avctx, AVFrame *frame)
             } else {
                 av_packet_unref(packet);
                 packet->size = 0;
+
+                // blocked waiting for decode result
+                if (decoder->sync)
+                    return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
             }
         }
     }
-- 
2.40.0


From ba5c782b923192e820b5c08aff61da5133b2dd1a Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Wed, 25 May 2022 12:35:53 +0800
Subject: [PATCH 12/24] avcodec/rkmppdec: Add H263/MPEG1/MPEG2/MPEG4

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 configure              | 4 ++++
 libavcodec/Makefile    | 4 ++++
 libavcodec/allcodecs.c | 4 ++++
 libavcodec/rkmppdec.c  | 8 ++++++++
 4 files changed, 20 insertions(+)

diff --git a/configure b/configure
index b2b6d45e78..8dd4294f28 100755
--- a/configure
+++ b/configure
@@ -3165,6 +3165,7 @@ av1_nvenc_encoder_deps="nvenc NV_ENC_PIC_PARAMS_AV1"
 av1_nvenc_encoder_select="atsc_a53"
 h263_v4l2m2m_decoder_deps="v4l2_m2m h263_v4l2_m2m"
 h263_v4l2m2m_encoder_deps="v4l2_m2m h263_v4l2_m2m"
+h263_rkmpp_decoder_deps="rkmpp"
 h264_amf_encoder_deps="amf"
 h264_crystalhd_decoder_select="crystalhd h264_mp4toannexb_bsf h264_parser"
 h264_cuvid_decoder_deps="cuvid"
@@ -3218,6 +3219,7 @@ mjpeg_vaapi_encoder_select="cbs_jpeg jpegtables vaapi_encode"
 mp3_mf_encoder_deps="mediafoundation"
 mpeg1_cuvid_decoder_deps="cuvid"
 mpeg1_v4l2m2m_decoder_deps="v4l2_m2m mpeg1_v4l2_m2m"
+mpeg1_rkmpp_decoder_deps="rkmpp"
 mpeg2_crystalhd_decoder_select="crystalhd"
 mpeg2_cuvid_decoder_deps="cuvid"
 mpeg2_mmal_decoder_deps="mmal"
@@ -3226,6 +3228,7 @@ mpeg2_qsv_decoder_select="qsvdec"
 mpeg2_qsv_encoder_select="qsvenc"
 mpeg2_vaapi_encoder_select="cbs_mpeg2 vaapi_encode"
 mpeg2_v4l2m2m_decoder_deps="v4l2_m2m mpeg2_v4l2_m2m"
+mpeg2_rkmpp_decoder_deps="rkmpp"
 mpeg4_crystalhd_decoder_select="crystalhd"
 mpeg4_cuvid_decoder_deps="cuvid"
 mpeg4_mediacodec_decoder_deps="mediacodec"
@@ -3233,6 +3236,7 @@ mpeg4_mmal_decoder_deps="mmal"
 mpeg4_omx_encoder_deps="omx"
 mpeg4_v4l2m2m_decoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
 mpeg4_v4l2m2m_encoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
+mpeg4_rkmpp_decoder_deps="rkmpp"
 msmpeg4_crystalhd_decoder_select="crystalhd"
 vc1_crystalhd_decoder_select="crystalhd"
 vc1_cuvid_decoder_deps="cuvid"
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 389253f5d0..504a31e83e 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -397,6 +397,7 @@ OBJS-$(CONFIG_H263_ENCODER)            += mpeg4video.o  \
                                           h263.o ituh263enc.o h263data.o
 OBJS-$(CONFIG_H263_V4L2M2M_DECODER)    += v4l2_m2m_dec.o
 OBJS-$(CONFIG_H263_V4L2M2M_ENCODER)    += v4l2_m2m_enc.o
+OBJS-$(CONFIG_H263_RKMPP_DECODER)      += rkmppdec.o
 OBJS-$(CONFIG_H264_DECODER)            += h264dec.o h264_cabac.o h264_cavlc.o \
                                           h264_direct.o h264_loopfilter.o  \
                                           h264_mb.o h264_picture.o \
@@ -529,6 +530,7 @@ OBJS-$(CONFIG_MPEG1VIDEO_DECODER)      += mpeg12dec.o mpeg12.o mpeg12data.o
 OBJS-$(CONFIG_MPEG1VIDEO_ENCODER)      += mpeg12enc.o mpeg12.o
 OBJS-$(CONFIG_MPEG1_CUVID_DECODER)     += cuviddec.o
 OBJS-$(CONFIG_MPEG1_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
+OBJS-$(CONFIG_MPEG1_RKMPP_DECODER)     += rkmppdec.o
 OBJS-$(CONFIG_MPEG2_MMAL_DECODER)      += mmaldec.o
 OBJS-$(CONFIG_MPEG2_QSV_DECODER)       += qsvdec.o
 OBJS-$(CONFIG_MPEG2_QSV_ENCODER)       += qsvenc_mpeg2.o
@@ -539,12 +541,14 @@ OBJS-$(CONFIG_MPEG2_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_MPEG2_VAAPI_ENCODER)     += vaapi_encode_mpeg2.o
 OBJS-$(CONFIG_MPEG2_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
 OBJS-$(CONFIG_MPEG4_DECODER)           += mpeg4videodsp.o xvididct.o
+OBJS-$(CONFIG_MPEG2_RKMPP_DECODER)     += rkmppdec.o
 OBJS-$(CONFIG_MPEG4_ENCODER)           += mpeg4videoenc.o
 OBJS-$(CONFIG_MPEG4_CUVID_DECODER)     += cuviddec.o
 OBJS-$(CONFIG_MPEG4_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_MPEG4_OMX_ENCODER)       += omx.o
 OBJS-$(CONFIG_MPEG4_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
 OBJS-$(CONFIG_MPEG4_V4L2M2M_ENCODER)   += v4l2_m2m_enc.o
+OBJS-$(CONFIG_MPEG4_RKMPP_DECODER)     += rkmppdec.o
 OBJS-$(CONFIG_MPL2_DECODER)            += mpl2dec.o ass.o
 OBJS-$(CONFIG_MSA1_DECODER)            += mss3.o
 OBJS-$(CONFIG_MSCC_DECODER)            += mscc.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index e593ad19af..84e57b3e1b 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -150,6 +150,7 @@ extern const FFCodec ff_h263i_decoder;
 extern const FFCodec ff_h263p_encoder;
 extern const FFCodec ff_h263p_decoder;
 extern const FFCodec ff_h263_v4l2m2m_decoder;
+extern const FFCodec ff_h263_rkmpp_decoder;
 extern const FFCodec ff_h264_decoder;
 extern const FFCodec ff_h264_crystalhd_decoder;
 extern const FFCodec ff_h264_v4l2m2m_decoder;
@@ -212,13 +213,16 @@ extern const FFCodec ff_mpeg4_decoder;
 extern const FFCodec ff_mpeg4_crystalhd_decoder;
 extern const FFCodec ff_mpeg4_v4l2m2m_decoder;
 extern const FFCodec ff_mpeg4_mmal_decoder;
+extern const AVCodec ff_mpeg4_rkmpp_decoder;
 extern const FFCodec ff_mpegvideo_decoder;
 extern const FFCodec ff_mpeg1_v4l2m2m_decoder;
+extern const AVCodec ff_mpeg1_rkmpp_decoder;
 extern const FFCodec ff_mpeg2_mmal_decoder;
 extern const FFCodec ff_mpeg2_crystalhd_decoder;
 extern const FFCodec ff_mpeg2_v4l2m2m_decoder;
 extern const FFCodec ff_mpeg2_qsv_decoder;
 extern const FFCodec ff_mpeg2_mediacodec_decoder;
+extern const AVCodec ff_mpeg2_rkmpp_decoder;
 extern const FFCodec ff_msa1_decoder;
 extern const FFCodec ff_mscc_decoder;
 extern const FFCodec ff_msmpeg4v1_decoder;
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 9539a48817..cd03174ee2 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -85,10 +85,14 @@ typedef struct {
 static MppCodingType rkmpp_get_codingtype(AVCodecContext *avctx)
 {
     switch (avctx->codec_id) {
+    case AV_CODEC_ID_H263:          return MPP_VIDEO_CodingH263;
     case AV_CODEC_ID_H264:          return MPP_VIDEO_CodingAVC;
     case AV_CODEC_ID_HEVC:          return MPP_VIDEO_CodingHEVC;
     case AV_CODEC_ID_VP8:           return MPP_VIDEO_CodingVP8;
     case AV_CODEC_ID_VP9:           return MPP_VIDEO_CodingVP9;
+    case AV_CODEC_ID_MPEG1VIDEO:    /* fallthrough */
+    case AV_CODEC_ID_MPEG2VIDEO:    return MPP_VIDEO_CodingMPEG2;
+    case AV_CODEC_ID_MPEG4:         return MPP_VIDEO_CodingMPEG4;
     default:                        return MPP_VIDEO_CodingUnused;
     }
 }
@@ -790,7 +794,11 @@ static const AVCodecHWConfigInternal *const rkmpp_hw_configs[] = {
         .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE | FF_CODEC_CAP_CONTIGUOUS_BUFFERS \
     };
 
+RKMPP_DEC(h263,  AV_CODEC_ID_H263,          NULL)
 RKMPP_DEC(h264,  AV_CODEC_ID_H264,          "h264_mp4toannexb")
 RKMPP_DEC(hevc,  AV_CODEC_ID_HEVC,          "hevc_mp4toannexb")
 RKMPP_DEC(vp8,   AV_CODEC_ID_VP8,           NULL)
 RKMPP_DEC(vp9,   AV_CODEC_ID_VP9,           NULL)
+RKMPP_DEC(mpeg1, AV_CODEC_ID_MPEG1VIDEO,    NULL)
+RKMPP_DEC(mpeg2, AV_CODEC_ID_MPEG2VIDEO,    NULL)
+RKMPP_DEC(mpeg4, AV_CODEC_ID_MPEG4,         "mpeg4_unpack_bframes")
-- 
2.40.0


From 27822b4269a2f5b7062c50b4ce4363a4f52f6cc6 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Sun, 29 Jan 2023 17:50:14 +0800
Subject: [PATCH 13/24] avcodec/rkmppdec: Add AV1

Note: For new chips like rk3588.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 configure              | 1 +
 libavcodec/Makefile    | 1 +
 libavcodec/allcodecs.c | 1 +
 libavcodec/rkmppdec.c  | 6 ++++--
 4 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/configure b/configure
index 8dd4294f28..3804f193a5 100755
--- a/configure
+++ b/configure
@@ -3163,6 +3163,7 @@ av1_mediacodec_decoder_deps="mediacodec"
 av1_mediacodec_decoder_extralibs="-landroid"
 av1_nvenc_encoder_deps="nvenc NV_ENC_PIC_PARAMS_AV1"
 av1_nvenc_encoder_select="atsc_a53"
+av1_rkmpp_decoder_deps="rkmpp"
 h263_v4l2m2m_decoder_deps="v4l2_m2m h263_v4l2_m2m"
 h263_v4l2m2m_encoder_deps="v4l2_m2m h263_v4l2_m2m"
 h263_rkmpp_decoder_deps="rkmpp"
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 504a31e83e..af0cbbbfe1 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -255,6 +255,7 @@ OBJS-$(CONFIG_AV1_CUVID_DECODER)       += cuviddec.o
 OBJS-$(CONFIG_AV1_MEDIACODEC_DECODER)  += mediacodecdec.o
 OBJS-$(CONFIG_AV1_NVENC_ENCODER)       += nvenc_av1.o nvenc.o
 OBJS-$(CONFIG_AV1_QSV_ENCODER)         += qsvenc_av1.o
+OBJS-$(CONFIG_AV1_RKMPP_DECODER)       += rkmppdec.o
 OBJS-$(CONFIG_AVRN_DECODER)            += avrndec.o
 OBJS-$(CONFIG_AVRP_DECODER)            += r210dec.o
 OBJS-$(CONFIG_AVRP_ENCODER)            += r210enc.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 84e57b3e1b..dd8164d2b1 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -842,6 +842,7 @@ extern const FFCodec ff_av1_nvenc_encoder;
 extern const FFCodec ff_av1_qsv_decoder;
 extern const FFCodec ff_av1_qsv_encoder;
 extern const FFCodec ff_av1_amf_encoder;
+extern const FFCodec ff_av1_rkmpp_decoder;
 extern const FFCodec ff_libopenh264_encoder;
 extern const FFCodec ff_libopenh264_decoder;
 extern const FFCodec ff_h264_amf_encoder;
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index cd03174ee2..32fe1ede6a 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -88,6 +88,7 @@ static MppCodingType rkmpp_get_codingtype(AVCodecContext *avctx)
     case AV_CODEC_ID_H263:          return MPP_VIDEO_CodingH263;
     case AV_CODEC_ID_H264:          return MPP_VIDEO_CodingAVC;
     case AV_CODEC_ID_HEVC:          return MPP_VIDEO_CodingHEVC;
+    case AV_CODEC_ID_AV1:           return MPP_VIDEO_CodingAV1;
     case AV_CODEC_ID_VP8:           return MPP_VIDEO_CodingVP8;
     case AV_CODEC_ID_VP9:           return MPP_VIDEO_CodingVP9;
     case AV_CODEC_ID_MPEG1VIDEO:    /* fallthrough */
@@ -168,8 +169,8 @@ static int rkmpp_prepare_decoder(AVCodecContext *avctx)
     MppPacket packet;
     int ret;
 
-    // send extra data
-    if (avctx->extradata_size) {
+    // HACK: somehow MPP cannot handle extra data for AV1
+    if (avctx->extradata_size && avctx->codec_id != AV_CODEC_ID_AV1) {
         ret = mpp_packet_init(&packet, avctx->extradata, avctx->extradata_size);
         if (ret < 0)
             return AVERROR_UNKNOWN;
@@ -797,6 +798,7 @@ static const AVCodecHWConfigInternal *const rkmpp_hw_configs[] = {
 RKMPP_DEC(h263,  AV_CODEC_ID_H263,          NULL)
 RKMPP_DEC(h264,  AV_CODEC_ID_H264,          "h264_mp4toannexb")
 RKMPP_DEC(hevc,  AV_CODEC_ID_HEVC,          "hevc_mp4toannexb")
+RKMPP_DEC(av1,   AV_CODEC_ID_AV1,           NULL)
 RKMPP_DEC(vp8,   AV_CODEC_ID_VP8,           NULL)
 RKMPP_DEC(vp9,   AV_CODEC_ID_VP9,           NULL)
 RKMPP_DEC(mpeg1, AV_CODEC_ID_MPEG1VIDEO,    NULL)
-- 
2.40.0


From 07bad22a207711d9860d5d66191a865f32d59881 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Mon, 27 Mar 2023 17:44:09 +0800
Subject: [PATCH 14/24] rkmppdec: Ignore special MPP format masks

We should use the basic format in format conversion.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libavcodec/rkmppdec.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 32fe1ede6a..dcaea9d435 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -100,7 +100,7 @@ static MppCodingType rkmpp_get_codingtype(AVCodecContext *avctx)
 
 static uint32_t rkmpp_get_frameformat(MppFrameFormat mppformat)
 {
-    switch (mppformat) {
+    switch (mppformat & MPP_FRAME_FMT_MASK) {
     case MPP_FMT_YUV420SP:          return DRM_FORMAT_NV12;
     case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_NV15;
     case MPP_FMT_YUV422SP:          return DRM_FORMAT_NV16;
@@ -110,7 +110,7 @@ static uint32_t rkmpp_get_frameformat(MppFrameFormat mppformat)
 
 static uint32_t rkmpp_get_avformat(MppFrameFormat mppformat)
 {
-    switch (mppformat) {
+    switch (mppformat & MPP_FRAME_FMT_MASK) {
     case MPP_FMT_YUV420SP:          return AV_PIX_FMT_NV12;
     case MPP_FMT_YUV420SP_10BIT:    return AV_PIX_FMT_NONE;
     case MPP_FMT_YUV422SP:          return AV_PIX_FMT_NV16;
@@ -121,7 +121,7 @@ static uint32_t rkmpp_get_avformat(MppFrameFormat mppformat)
 #if CONFIG_LIBRGA
 static uint32_t rkmpp_get_rgaformat(MppFrameFormat mppformat)
 {
-    switch (mppformat) {
+    switch (mppformat & MPP_FRAME_FMT_MASK) {
     case MPP_FMT_YUV420SP:          return RK_FORMAT_YCbCr_420_SP;
     case MPP_FMT_YUV420SP_10BIT:    return RK_FORMAT_YCbCr_420_SP_10B;
     case MPP_FMT_YUV422SP:          return RK_FORMAT_YCbCr_422_SP;
-- 
2.40.0


From 5910b3c4944c51a762175c461eec4f4781a3234f Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Thu, 20 Apr 2023 15:23:26 +0200
Subject: [PATCH 15/24] Prioritize RKMPP decoders first

---
 libavcodec/allcodecs.c | 19 ++++++++++---------
 1 file changed, 10 insertions(+), 9 deletions(-)

diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index dd8164d2b1..ba08c937d2 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -34,6 +34,16 @@
 #include "codec_id.h"
 #include "codec_internal.h"
 
+extern const FFCodec ff_av1_rkmpp_decoder;
+extern const FFCodec ff_h263_rkmpp_decoder;
+extern const FFCodec ff_h264_rkmpp_decoder;
+extern const FFCodec ff_hevc_rkmpp_decoder;
+extern const FFCodec ff_mpeg1_rkmpp_decoder;
+extern const FFCodec ff_mpeg2_rkmpp_decoder;
+extern const FFCodec ff_mpeg4_rkmpp_decoder;
+extern const FFCodec ff_vp8_rkmpp_decoder;
+extern const FFCodec ff_vp9_rkmpp_decoder;
+
 extern const FFCodec ff_a64multi_encoder;
 extern const FFCodec ff_a64multi5_encoder;
 extern const FFCodec ff_aasc_decoder;
@@ -150,7 +160,6 @@ extern const FFCodec ff_h263i_decoder;
 extern const FFCodec ff_h263p_encoder;
 extern const FFCodec ff_h263p_decoder;
 extern const FFCodec ff_h263_v4l2m2m_decoder;
-extern const FFCodec ff_h263_rkmpp_decoder;
 extern const FFCodec ff_h264_decoder;
 extern const FFCodec ff_h264_crystalhd_decoder;
 extern const FFCodec ff_h264_v4l2m2m_decoder;
@@ -158,12 +167,10 @@ extern const FFCodec ff_h264_mediacodec_decoder;
 extern const FFCodec ff_h264_mediacodec_encoder;
 extern const FFCodec ff_h264_mmal_decoder;
 extern const FFCodec ff_h264_qsv_decoder;
-extern const FFCodec ff_h264_rkmpp_decoder;
 extern const FFCodec ff_hap_encoder;
 extern const FFCodec ff_hap_decoder;
 extern const FFCodec ff_hevc_decoder;
 extern const FFCodec ff_hevc_qsv_decoder;
-extern const FFCodec ff_hevc_rkmpp_decoder;
 extern const FFCodec ff_hevc_v4l2m2m_decoder;
 extern const FFCodec ff_hnm4_video_decoder;
 extern const FFCodec ff_hq_hqa_decoder;
@@ -213,16 +220,13 @@ extern const FFCodec ff_mpeg4_decoder;
 extern const FFCodec ff_mpeg4_crystalhd_decoder;
 extern const FFCodec ff_mpeg4_v4l2m2m_decoder;
 extern const FFCodec ff_mpeg4_mmal_decoder;
-extern const AVCodec ff_mpeg4_rkmpp_decoder;
 extern const FFCodec ff_mpegvideo_decoder;
 extern const FFCodec ff_mpeg1_v4l2m2m_decoder;
-extern const AVCodec ff_mpeg1_rkmpp_decoder;
 extern const FFCodec ff_mpeg2_mmal_decoder;
 extern const FFCodec ff_mpeg2_crystalhd_decoder;
 extern const FFCodec ff_mpeg2_v4l2m2m_decoder;
 extern const FFCodec ff_mpeg2_qsv_decoder;
 extern const FFCodec ff_mpeg2_mediacodec_decoder;
-extern const AVCodec ff_mpeg2_rkmpp_decoder;
 extern const FFCodec ff_msa1_decoder;
 extern const FFCodec ff_mscc_decoder;
 extern const FFCodec ff_msmpeg4v1_decoder;
@@ -381,10 +385,8 @@ extern const FFCodec ff_vp6a_decoder;
 extern const FFCodec ff_vp6f_decoder;
 extern const FFCodec ff_vp7_decoder;
 extern const FFCodec ff_vp8_decoder;
-extern const FFCodec ff_vp8_rkmpp_decoder;
 extern const FFCodec ff_vp8_v4l2m2m_decoder;
 extern const FFCodec ff_vp9_decoder;
-extern const FFCodec ff_vp9_rkmpp_decoder;
 extern const FFCodec ff_vp9_v4l2m2m_decoder;
 extern const FFCodec ff_vqa_decoder;
 extern const FFCodec ff_vqc_decoder;
@@ -842,7 +844,6 @@ extern const FFCodec ff_av1_nvenc_encoder;
 extern const FFCodec ff_av1_qsv_decoder;
 extern const FFCodec ff_av1_qsv_encoder;
 extern const FFCodec ff_av1_amf_encoder;
-extern const FFCodec ff_av1_rkmpp_decoder;
 extern const FFCodec ff_libopenh264_encoder;
 extern const FFCodec ff_libopenh264_decoder;
 extern const FFCodec ff_h264_amf_encoder;
-- 
2.40.0


From 035feef7fdc3ed1378b13ce8d28ad4237cac48b2 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Fri, 7 Apr 2023 16:20:13 +0200
Subject: [PATCH 16/24] Remove librga

---
 configure             |  7 +----
 libavcodec/rkmppdec.c | 68 +------------------------------------------
 2 files changed, 2 insertions(+), 73 deletions(-)

diff --git a/configure b/configure
index 3804f193a5..84c6850fca 100755
--- a/configure
+++ b/configure
@@ -349,7 +349,6 @@ External library support:
   --enable-omx             enable OpenMAX IL code [no]
   --enable-omx-rpi         enable OpenMAX IL code for Raspberry Pi [no]
   --enable-rkmpp           enable Rockchip Media Process Platform code [no]
-  --enable-librga          enable Rockchip RGA 2D accel via librga [autodetect]
   --disable-v4l2-m2m       disable V4L2 mem2mem code [autodetect]
   --disable-vaapi          disable Video Acceleration API (mainly Unix/Intel) code [autodetect]
   --disable-vdpau          disable Nvidia Video Decode and Presentation API for Unix code [autodetect]
@@ -1893,7 +1892,6 @@ HWACCEL_AUTODETECT_LIBRARY_LIST="
     videotoolbox
     vulkan
     v4l2_m2m
-    librga
 "
 
 # catchall list of things that require external libs to link
@@ -6796,13 +6794,10 @@ enabled openssl           && { { check_pkg_config openssl "openssl >= 3.0.0" ope
                                check_lib openssl openssl/ssl.h SSL_library_init -lssl -lcrypto -lws2_32 -lgdi32 ||
                                die "ERROR: openssl not found"; }
 enabled pocketsphinx      && require_pkg_config pocketsphinx pocketsphinx pocketsphinx/pocketsphinx.h ps_init
-enabled librga            && check_lib librga rga/RgaApi.h c_RkRgaInit -lrga && prepend rkmpp_deps "librga"
 enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp  rockchip/rk_mpi.h mpp_create &&
                                require_pkg_config rockchip_mpp "rockchip_mpp >= 1.3.7" rockchip/rk_mpi.h mpp_create &&
                                { enabled libdrm ||
-                                 die "ERROR: rkmpp requires --enable-libdrm"; } &&
-                               { enabled librga ||
-                                 warn "using rkmpp without librga"; }
+                                 die "ERROR: rkmpp requires --enable-libdrm"; }
                              }
 enabled vapoursynth       && require_pkg_config vapoursynth "vapoursynth-script >= 42" VSScript.h vsscript_init
 
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index dcaea9d435..908ab3963b 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -40,11 +40,6 @@
 #include "libavutil/imgutils.h"
 #include "libavutil/log.h"
 
-#if CONFIG_LIBRGA
-#include <rga/rga.h>
-#include <rga/RgaApi.h>
-#endif
-
 // HACK: Older BSP kernel use NA12 for NV15.
 #ifndef DRM_FORMAT_NV15 // fourcc_code('N', 'V', '1', '5')
 #define DRM_FORMAT_NV15 fourcc_code('N', 'A', '1', '2')
@@ -118,18 +113,6 @@ static uint32_t rkmpp_get_avformat(MppFrameFormat mppformat)
     }
 }
 
-#if CONFIG_LIBRGA
-static uint32_t rkmpp_get_rgaformat(MppFrameFormat mppformat)
-{
-    switch (mppformat & MPP_FRAME_FMT_MASK) {
-    case MPP_FMT_YUV420SP:          return RK_FORMAT_YCbCr_420_SP;
-    case MPP_FMT_YUV420SP_10BIT:    return RK_FORMAT_YCbCr_420_SP_10B;
-    case MPP_FMT_YUV422SP:          return RK_FORMAT_YCbCr_422_SP;
-    default:                        return RK_FORMAT_UNKNOWN;
-    }
-}
-#endif
-
 static int rkmpp_close_decoder(AVCodecContext *avctx)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
@@ -314,9 +297,6 @@ static int rkmpp_convert_frame(AVCodecContext *avctx, AVFrame *frame,
     char *dst_y = frame->data[0];
     char *dst_u = frame->data[1];
     char *dst_v = frame->data[2];
-#if CONFIG_LIBRGA
-    RgaSURF_FORMAT format = rkmpp_get_rgaformat(mpp_frame_get_fmt(mppframe));
-#endif
     int width = mpp_frame_get_width(mppframe);
     int height = mpp_frame_get_height(mppframe);
     int hstride = mpp_frame_get_hor_stride(mppframe);
@@ -326,51 +306,6 @@ static int rkmpp_convert_frame(AVCodecContext *avctx, AVFrame *frame,
     int v_pitch = frame->linesize[2];
     int i, j;
 
-#if CONFIG_LIBRGA
-    rga_info_t src_info = {0};
-    rga_info_t dst_info = {0};
-    int dst_height = (dst_u - dst_y) / y_pitch;
-
-    static int rga_supported = 1;
-    static int rga_inited = 0;
-
-    if (!rga_supported)
-        goto bail;
-
-    if (!rga_inited) {
-        if (c_RkRgaInit() < 0) {
-            rga_supported = 0;
-            av_log(avctx, AV_LOG_WARNING, "RGA not available\n");
-            goto bail;
-        }
-        rga_inited = 1;
-    }
-
-    if (format == RK_FORMAT_UNKNOWN)
-        goto bail;
-
-    if (u_pitch != y_pitch / 2 || v_pitch != y_pitch / 2 ||
-        dst_u != dst_y + y_pitch * dst_height ||
-        dst_v != dst_u + u_pitch * dst_height / 2)
-        goto bail;
-
-    src_info.fd = mpp_buffer_get_fd(buffer);
-    src_info.mmuFlag = 1;
-    rga_set_rect(&src_info.rect, 0, 0, width, height, hstride, vstride,
-                 format);
-
-    dst_info.virAddr = dst_y;
-    dst_info.mmuFlag = 1;
-    rga_set_rect(&dst_info.rect, 0, 0, frame->width, frame->height,
-                 y_pitch, dst_height, RK_FORMAT_YCbCr_420_P);
-
-    if (c_RkRgaBlit(&src_info, &dst_info, NULL) < 0)
-        goto bail;
-
-    return 0;
-
-bail:
-#endif
     if (mpp_frame_get_fmt(mppframe) != MPP_FMT_YUV420SP) {
         av_log(avctx, AV_LOG_WARNING, "Unable to convert\n");
         return -1;
@@ -533,7 +468,7 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME) {
         ret = ff_get_buffer(avctx, frame, 0);
         if (ret < 0)
-            goto out;
+            goto fail;
     }
 
     // setup general frame fields
@@ -612,7 +547,6 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
 
     return 0;
 
-out:
 fail:
     if (mppframe)
         mpp_frame_deinit(&mppframe);
-- 
2.40.0


From 3a656a5cf3545ebcfec88ca9b2ca4fad2ff3f286 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Sun, 16 Apr 2023 19:17:44 +0200
Subject: [PATCH 17/24] Faster sw conversion with libyuv using SIMD

---
 configure             |  3 +++
 libavcodec/rkmppdec.c | 47 ++++++++++++++++++++-----------------------
 2 files changed, 25 insertions(+), 25 deletions(-)

diff --git a/configure b/configure
index 84c6850fca..7b7c4c0872 100755
--- a/configure
+++ b/configure
@@ -6796,6 +6796,9 @@ enabled openssl           && { { check_pkg_config openssl "openssl >= 3.0.0" ope
 enabled pocketsphinx      && require_pkg_config pocketsphinx pocketsphinx pocketsphinx/pocketsphinx.h ps_init
 enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp  rockchip/rk_mpi.h mpp_create &&
                                require_pkg_config rockchip_mpp "rockchip_mpp >= 1.3.7" rockchip/rk_mpi.h mpp_create &&
+                               { check_lib libyuv libyuv/planar_functions.h SplitUVPlane -lyuv ||
+                                 die "ERROR: libyuv is necessary for rkmpp"; } &&
+                               prepend rkmpp_deps "libyuv" &&
                                { enabled libdrm ||
                                  die "ERROR: rkmpp requires --enable-libdrm"; }
                              }
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 908ab3963b..1cca4b6e7d 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -39,6 +39,7 @@
 #include "libavutil/hwcontext_drm.h"
 #include "libavutil/imgutils.h"
 #include "libavutil/log.h"
+#include "libyuv/planar_functions.h"
 
 // HACK: Older BSP kernel use NA12 for NV15.
 #ifndef DRM_FORMAT_NV15 // fourcc_code('N', 'V', '1', '5')
@@ -290,44 +291,41 @@ static void rkmpp_release_frame(void *opaque, uint8_t *data)
     av_free(desc);
 }
 
+static void rkmpp_release_buffer(void *opaque, uint8_t *data)
+{
+    MppFrame mppframe = opaque;
+    mpp_frame_deinit(&mppframe);
+}
+
 static int rkmpp_convert_frame(AVCodecContext *avctx, AVFrame *frame,
                                MppFrame mppframe, MppBuffer buffer)
 {
     char *src = mpp_buffer_get_ptr(buffer);
-    char *dst_y = frame->data[0];
     char *dst_u = frame->data[1];
     char *dst_v = frame->data[2];
-    int width = mpp_frame_get_width(mppframe);
-    int height = mpp_frame_get_height(mppframe);
     int hstride = mpp_frame_get_hor_stride(mppframe);
     int vstride = mpp_frame_get_ver_stride(mppframe);
-    int y_pitch = frame->linesize[0];
     int u_pitch = frame->linesize[1];
     int v_pitch = frame->linesize[2];
-    int i, j;
 
-    if (mpp_frame_get_fmt(mppframe) != MPP_FMT_YUV420SP) {
-        av_log(avctx, AV_LOG_WARNING, "Unable to convert\n");
-        return -1;
+    //data[0] points to buf[1] where the mppbuffer is referenced for y plane
+    //so that we can still use y plane without extra copies
+    //data[1,2] points to allready allocated AVBuffer Pool (buf[0]), we will convert to
+    //that buffer only u+v planes, which is half the size operation
+    frame->data[0] = mpp_buffer_get_ptr(buffer);
+    frame->buf[1] = av_buffer_create(frame->data[0], mpp_buffer_get_size(buffer),
+            rkmpp_release_buffer, mppframe,
+            AV_BUFFER_FLAG_READONLY);
+    if (!frame->buf[1]) {
+        return AVERROR(ENOMEM);
     }
-
-    av_log(avctx, AV_LOG_WARNING, "Doing slow software conversion\n");
-
-    for (i = 0; i < frame->height; i++)
-        memcpy(dst_y + i * y_pitch, src + i * hstride, frame->width);
+    frame->linesize[0] = hstride;
+    av_log(avctx, AV_LOG_WARNING, "Doing software conversion for uv planes\n");
 
     src += hstride * vstride;
 
-    for (i = 0; i < frame->height / 2; i++) {
-        for (j = 0; j < frame->width; j++) {
-            dst_u[j] = src[2 * j + 0];
-            dst_v[j] = src[2 * j + 1];
-        }
-        dst_u += u_pitch;
-        dst_v += v_pitch;
-        src += hstride;
-    }
-
+    SplitUVPlane(src, hstride, dst_u, u_pitch, dst_v, v_pitch,
+            (frame->width + 1) >> 1, (frame->height + 1) >> 1);
     return 0;
 }
 
@@ -487,8 +485,7 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     frame->top_field_first  = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST);
 
     if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME) {
-        ret = rkmpp_convert_frame(avctx, frame, mppframe, buffer);
-        goto out;
+        return rkmpp_convert_frame(avctx, frame, mppframe, buffer);
     }
 
     mppformat = mpp_frame_get_fmt(mppframe);
-- 
2.40.0


From ebe5776cef27e618ac8b75450f43ead8b0cb6b13 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Tue, 18 Apr 2023 19:05:56 +0200
Subject: [PATCH 18/24] Use internal rga to convert from mppbuffer to avbuffer

---
 libavcodec/rga.h      | 574 ++++++++++++++++++++++++++++++++++++++++++
 libavcodec/rkmppdec.c |  80 +++++-
 2 files changed, 653 insertions(+), 1 deletion(-)
 create mode 100644 libavcodec/rga.h

diff --git a/libavcodec/rga.h b/libavcodec/rga.h
new file mode 100644
index 0000000000..9595558de0
--- /dev/null
+++ b/libavcodec/rga.h
@@ -0,0 +1,574 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _RGA_DRIVER_H_
+#define _RGA_DRIVER_H_
+
+/* Use 'r' as magic number */
+#define RGA_IOC_MAGIC		'r'
+#define RGA_IOW(nr, type)	_IOW(RGA_IOC_MAGIC, nr, type)
+#define RGA_IOR(nr, type)	_IOR(RGA_IOC_MAGIC, nr, type)
+#define RGA_IOWR(nr, type)	_IOWR(RGA_IOC_MAGIC, nr, type)
+
+#define RGA_IOC_GET_DRVIER_VERSION	RGA_IOR(0x1, struct rga_version_t)
+#define RGA_IOC_GET_HW_VERSION		RGA_IOR(0x2, struct rga_hw_versions_t)
+#define RGA_IOC_IMPORT_BUFFER		RGA_IOWR(0x3, struct rga_buffer_pool)
+#define RGA_IOC_RELEASE_BUFFER		RGA_IOW(0x4, struct rga_buffer_pool)
+#define RGA_IOC_REQUEST_CREATE		RGA_IOR(0x5, uint32_t)
+#define RGA_IOC_REQUEST_SUBMIT		RGA_IOWR(0x6, struct rga_user_request)
+#define RGA_IOC_REQUEST_CONFIG		RGA_IOWR(0x7, struct rga_user_request)
+#define RGA_IOC_REQUEST_CANCEL		RGA_IOWR(0x8, uint32_t)
+
+#define RGA_BLIT_SYNC			0x5017
+#define RGA_BLIT_ASYNC			0x5018
+#define RGA_FLUSH			0x5019
+#define RGA_GET_RESULT			0x501a
+#define RGA_GET_VERSION			0x501b
+#define RGA_CACHE_FLUSH			0x501c
+
+#define RGA2_GET_VERSION		0x601b
+#define RGA_IMPORT_DMA			0x601d
+#define RGA_RELEASE_DMA			0x601e
+
+#define RGA_TASK_NUM_MAX		50
+
+#define RGA_OUT_OF_RESOURCES		-10
+#define RGA_MALLOC_ERROR		-11
+
+#define SCALE_DOWN_LARGE		1
+#define SCALE_UP_LARGE			1
+
+#define RGA_BUFFER_POOL_SIZE_MAX 40
+
+#define RGA3_MAJOR_VERSION_MASK	 (0xF0000000)
+#define RGA3_MINOR_VERSION_MASK	 (0x0FF00000)
+#define RGA3_SVN_VERSION_MASK	 (0x000FFFFF)
+
+#define RGA2_MAJOR_VERSION_MASK	 (0xFF000000)
+#define RGA2_MINOR_VERSION_MASK	 (0x00F00000)
+#define RGA2_SVN_VERSION_MASK	 (0x000FFFFF)
+
+#define RGA_MODE_ROTATE_0	 (1<<0)
+#define RGA_MODE_ROTATE_90	 (1<<1)
+#define RGA_MODE_ROTATE_180	 (1<<2)
+#define RGA_MODE_ROTATE_270	 (1<<3)
+#define RGA_MODE_X_MIRROR	 (1<<4)
+#define RGA_MODE_Y_MIRROR	 (1<<5)
+
+#define RGA_MODE_CSC_BT601L	 (1<<0)
+#define RGA_MODE_CSC_BT601F	 (1<<1)
+#define RGA_MODE_CSC_BT709	 (1<<2)
+#define RGA_MODE_CSC_BT2020	 (1<<3)
+
+#define RGA_MODE_ROTATE_MASK (\
+		RGA_MODE_ROTATE_0 | \
+		RGA_MODE_ROTATE_90 | \
+		RGA_MODE_ROTATE_180 | \
+		RGA_MODE_ROTATE_270 | \
+		RGA_MODE_X_MIRROR | \
+		RGA_MODE_Y_MIRROR)
+
+enum rga_memory_type {
+	RGA_DMA_BUFFER = 0,
+	RGA_VIRTUAL_ADDRESS,
+	RGA_PHYSICAL_ADDRESS,
+	RGA_DMA_BUFFER_PTR,
+};
+
+enum rga_scale_up_mode {
+	RGA_SCALE_UP_NONE	= 0x0,
+	RGA_SCALE_UP_BIC	= 0x1,
+};
+
+enum rga_scale_down_mode {
+	RGA_SCALE_DOWN_NONE	= 0x0,
+	RGA_SCALE_DOWN_AVG	= 0x1,
+};
+
+/* RGA process mode enum */
+enum {
+	BITBLT_MODE			= 0x0,
+	COLOR_PALETTE_MODE		= 0x1,
+	COLOR_FILL_MODE			= 0x2,
+	/* used by rga2 */
+	UPDATE_PALETTE_TABLE_MODE	= 0x6,
+	UPDATE_PATTEN_BUF_MODE		= 0x7,
+}; /*render mode*/
+
+/* RGA rd_mode */
+enum {
+	RGA_RASTER_MODE			 = 0x1 << 0,
+	RGA_FBC_MODE			 = 0x1 << 1,
+	RGA_TILE_MODE			 = 0x1 << 2,
+};
+
+enum {
+	RGA_CONTEXT_NONE		= 0x0,
+	RGA_CONTEXT_SRC_FIX_ENABLE	= 0x1 << 0,
+	RGA_CONTEXT_SRC_CACHE_INFO	= 0x1 << 1,
+	RGA_CONTEXT_SRC_MASK		= RGA_CONTEXT_SRC_FIX_ENABLE |
+					  RGA_CONTEXT_SRC_CACHE_INFO,
+	RGA_CONTEXT_PAT_FIX_ENABLE	= 0x1 << 2,
+	RGA_CONTEXT_PAT_CACHE_INFO	= 0x1 << 3,
+	RGA_CONTEXT_PAT_MASK		= RGA_CONTEXT_PAT_FIX_ENABLE |
+					  RGA_CONTEXT_PAT_CACHE_INFO,
+	RGA_CONTEXT_DST_FIX_ENABLE	= 0x1 << 4,
+	RGA_CONTEXT_DST_CACHE_INFO	= 0x1 << 5,
+	RGA_CONTEXT_DST_MASK		= RGA_CONTEXT_DST_FIX_ENABLE |
+					  RGA_CONTEXT_DST_CACHE_INFO,
+};
+
+/* RGA feature */
+enum {
+	RGA_COLOR_FILL			= 0x1 << 0,
+	RGA_COLOR_PALETTE		= 0x1 << 1,
+	RGA_COLOR_KEY			= 0x1 << 2,
+	RGA_ROP_CALCULATE		= 0x1 << 3,
+	RGA_NN_QUANTIZE			= 0x1 << 4,
+	RGA_OSD_BLEND			= 0x1 << 5,
+	RGA_DITHER			= 0x1 << 6,
+	RGA_MOSAIC			= 0x1 << 7,
+	RGA_YIN_YOUT			= 0x1 << 8,
+	RGA_YUV_HDS			= 0x1 << 9,
+	RGA_YUV_VDS			= 0x1 << 10,
+	RGA_OSD				= 0x1 << 11,
+	RGA_PRE_INTR			= 0x1 << 12,
+};
+
+enum rga_surf_format {
+	RGA_FORMAT_RGBA_8888		= 0x0,
+	RGA_FORMAT_RGBX_8888		= 0x1,
+	RGA_FORMAT_RGB_888		= 0x2,
+	RGA_FORMAT_BGRA_8888		= 0x3,
+	RGA_FORMAT_RGB_565		= 0x4,
+	RGA_FORMAT_RGBA_5551		= 0x5,
+	RGA_FORMAT_RGBA_4444		= 0x6,
+	RGA_FORMAT_BGR_888		= 0x7,
+
+	RGA_FORMAT_YCbCr_422_SP		= 0x8,
+	RGA_FORMAT_YCbCr_422_P		= 0x9,
+	RGA_FORMAT_YCbCr_420_SP		= 0xa,
+	RGA_FORMAT_YCbCr_420_P		= 0xb,
+
+	RGA_FORMAT_YCrCb_422_SP		= 0xc,
+	RGA_FORMAT_YCrCb_422_P		= 0xd,
+	RGA_FORMAT_YCrCb_420_SP		= 0xe,
+	RGA_FORMAT_YCrCb_420_P		= 0xf,
+
+	RGA_FORMAT_BPP1			= 0x10,
+	RGA_FORMAT_BPP2			= 0x11,
+	RGA_FORMAT_BPP4			= 0x12,
+	RGA_FORMAT_BPP8			= 0x13,
+
+	RGA_FORMAT_Y4			= 0x14,
+	RGA_FORMAT_YCbCr_400		= 0x15,
+
+	RGA_FORMAT_BGRX_8888		= 0x16,
+
+	RGA_FORMAT_YVYU_422		= 0x18,
+	RGA_FORMAT_YVYU_420		= 0x19,
+	RGA_FORMAT_VYUY_422		= 0x1a,
+	RGA_FORMAT_VYUY_420		= 0x1b,
+	RGA_FORMAT_YUYV_422		= 0x1c,
+	RGA_FORMAT_YUYV_420		= 0x1d,
+	RGA_FORMAT_UYVY_422		= 0x1e,
+	RGA_FORMAT_UYVY_420		= 0x1f,
+
+	RGA_FORMAT_YCbCr_420_SP_10B	= 0x20,
+	RGA_FORMAT_YCrCb_420_SP_10B	= 0x21,
+	RGA_FORMAT_YCbCr_422_SP_10B	= 0x22,
+	RGA_FORMAT_YCrCb_422_SP_10B	= 0x23,
+
+	RGA_FORMAT_BGR_565		= 0x24,
+	RGA_FORMAT_BGRA_5551		= 0x25,
+	RGA_FORMAT_BGRA_4444		= 0x26,
+
+	RGA_FORMAT_ARGB_8888		= 0x28,
+	RGA_FORMAT_XRGB_8888		= 0x29,
+	RGA_FORMAT_ARGB_5551		= 0x2a,
+	RGA_FORMAT_ARGB_4444		= 0x2b,
+	RGA_FORMAT_ABGR_8888		= 0x2c,
+	RGA_FORMAT_XBGR_8888		= 0x2d,
+	RGA_FORMAT_ABGR_5551		= 0x2e,
+	RGA_FORMAT_ABGR_4444		= 0x2f,
+
+	RGA_FORMAT_RGBA_2BPP		= 0x30,
+
+	RGA_FORMAT_UNKNOWN		= 0x100,
+};
+
+#define RGA_SCHED_PRIORITY_DEFAULT 0
+#define RGA_SCHED_PRIORITY_MAX 6
+
+#define RGA_VERSION_SIZE	16
+#define RGA_HW_SIZE		5
+
+struct rga_version_t {
+	uint32_t major;
+	uint32_t minor;
+	uint32_t revision;
+	uint8_t str[RGA_VERSION_SIZE];
+};
+
+struct rga_hw_versions_t {
+	struct rga_version_t version[RGA_HW_SIZE];
+	uint32_t size;
+};
+
+struct rga_memory_parm {
+	uint32_t width;
+	uint32_t height;
+	uint32_t format;
+
+	uint32_t size;
+};
+
+struct rga_external_buffer {
+	uint64_t memory;
+	uint32_t type;
+
+	uint32_t handle;
+	struct rga_memory_parm memory_parm;
+
+	uint8_t reserve[252];
+};
+
+struct rga_buffer_pool {
+	uint64_t buffers_ptr;
+	uint32_t size;
+};
+
+struct rga_color_fill_t {
+	int16_t gr_x_a;
+	int16_t gr_y_a;
+	int16_t gr_x_b;
+	int16_t gr_y_b;
+	int16_t gr_x_g;
+	int16_t gr_y_g;
+	int16_t gr_x_r;
+	int16_t gr_y_r;
+};
+
+/***************************************/
+/* porting from rga.h for msg convert */
+/***************************************/
+
+struct rga_fading_t {
+	uint8_t b;
+	uint8_t g;
+	uint8_t r;
+	uint8_t res;
+};
+
+struct rga_mmu_t {
+	uint8_t mmu_en;
+	uint64_t base_addr;
+	/*
+	 * [0] mmu enable [1] src_flush [2] dst_flush
+	 * [3] CMD_flush [4~5] page size
+	 */
+	uint32_t mmu_flag;
+};
+
+struct rga_rect_t {
+	uint16_t xmin;
+	/* width - 1 */
+	uint16_t xmax;
+	uint16_t ymin;
+	/* height - 1 */
+	uint16_t ymax;
+};
+
+struct rga_point_t {
+	uint16_t x;
+	uint16_t y;
+};
+
+struct rga_line_draw_t {
+	/* LineDraw_start_point	*/
+	struct rga_point_t start_point;
+	/* LineDraw_end_point */
+	struct rga_point_t end_point;
+	/* LineDraw_color */
+	uint32_t color;
+	/* (enum) LineDrawing mode sel */
+	uint32_t flag;
+	/* range 1~16 */
+	uint32_t line_width;
+};
+
+/* color space convert coefficient. */
+struct rga_csc_coe {
+	int16_t r_v;
+	int16_t g_y;
+	int16_t b_u;
+	int32_t off;
+};
+
+struct rga_full_csc {
+	uint8_t flag;
+	struct rga_csc_coe coe_y;
+	struct rga_csc_coe coe_u;
+	struct rga_csc_coe coe_v;
+};
+
+struct rga_mosaic_info {
+	uint8_t enable;
+	uint8_t mode;
+};
+
+/* MAX(min, (max - channel_value)) */
+struct rga_osd_invert_factor {
+	uint8_t alpha_max;
+	uint8_t alpha_min;
+	uint8_t yg_max;
+	uint8_t yg_min;
+	uint8_t crb_max;
+	uint8_t crb_min;
+};
+
+struct rga_color {
+	union {
+		struct {
+			uint8_t red;
+			uint8_t green;
+			uint8_t blue;
+			uint8_t alpha;
+		};
+		uint32_t value;
+	};
+};
+
+struct rga_osd_bpp2 {
+	uint8_t  ac_swap;		// ac swap flag
+					// 0: CA
+					// 1: AC
+	uint8_t  endian_swap;		// rgba2bpp endian swap
+					// 0: Big endian
+					// 1: Little endian
+	struct rga_color color0;
+	struct rga_color color1;
+};
+
+struct rga_osd_mode_ctrl {
+	uint8_t mode;			// OSD cal mode:
+					//   0b'1: statistics mode
+					//   1b'1: auto inversion overlap mode
+	uint8_t direction_mode;		// horizontal or vertical
+					//   0: horizontal
+					//   1: vertical
+	uint8_t width_mode;		// using @fix_width or LUT width
+					//   0: fix width
+					//   1: LUT width
+	uint16_t block_fix_width;	// OSD block fixed width
+					//   real width = (fix_width + 1) * 2
+	uint8_t block_num;		// OSD block num
+	uint16_t flags_index;		// auto invert flags index
+
+	/* invertion config */
+	uint8_t color_mode;		// selete color
+					//   0: src1 color
+					//   1: config data color
+	uint8_t invert_flags_mode;	// invert flag selete
+					//   0: use RAM flag
+					//   1: usr last result
+	uint8_t default_color_sel;	// default color mode
+					//   0: default is bright
+					//   1: default is dark
+	uint8_t invert_enable;		// invert channel enable
+					//   1 << 0: alpha enable
+					//   1 << 1: Y/G disable
+					//   1 << 3: C/RB disable
+	uint8_t invert_mode;		// invert cal mode
+					//   0: normal(max-data)
+					//   1: swap
+	uint8_t invert_thresh;		// if luma > thresh, osd_flag to be 1
+	uint8_t unfix_index;		// OSD width config index
+};
+
+struct rga_osd_info {
+	uint8_t  enable;
+
+	struct rga_osd_mode_ctrl mode_ctrl;
+	struct rga_osd_invert_factor cal_factor;
+	struct rga_osd_bpp2 bpp2_info;
+
+	union {
+		struct {
+			uint32_t last_flags0;
+			uint32_t last_flags1;
+		};
+		uint64_t last_flags;
+	};
+
+	union {
+		struct {
+			uint32_t cur_flags0;
+			uint32_t cur_flags1;
+		};
+		uint64_t cur_flags;
+	};
+};
+
+struct rga_pre_intr_info {
+	uint8_t enable;
+
+	uint8_t read_intr_en;
+	uint8_t write_intr_en;
+	uint8_t read_hold_en;
+	uint32_t read_threshold;
+	uint32_t write_start;
+	uint32_t write_step;
+};
+
+struct rga_img_info_t {
+	/* yrgb	mem addr */
+	uint64_t yrgb_addr;
+	/* cb/cr mem addr */
+	uint64_t uv_addr;
+	/* cr mem addr */
+	uint64_t v_addr;
+	/* definition by RK_FORMAT */
+	uint32_t format;
+
+	uint16_t act_w;
+	uint16_t act_h;
+	uint16_t x_offset;
+	uint16_t y_offset;
+
+	uint16_t vir_w;
+	uint16_t vir_h;
+
+	uint16_t endian_mode;
+	/* useless */
+	uint16_t alpha_swap;
+
+	/* used by RGA3 */
+	uint16_t rotate_mode;
+	uint16_t rd_mode;
+
+	uint16_t is_10b_compact;
+	uint16_t is_10b_endian;
+
+	uint16_t enable;
+};
+
+struct rga_req {
+	/* (enum) process mode sel */
+	uint8_t render_mode;
+
+	struct rga_img_info_t src;
+	struct rga_img_info_t dst;
+	struct rga_img_info_t pat;
+
+	/* rop4 mask addr */
+	uint64_t rop_mask_addr;
+	/* LUT addr */
+	uint64_t LUT_addr;
+
+	/* dst clip window default value is dst_vir */
+	/* value from [0, w-1] / [0, h-1]*/
+	struct rga_rect_t clip;
+
+	/* dst angle default value 0 16.16 scan from table */
+	int32_t sina;
+	/* dst angle default value 0 16.16 scan from table */
+	int32_t cosa;
+
+	/* alpha rop process flag		 */
+	/* ([0] = 1 alpha_rop_enable)	 */
+	/* ([1] = 1 rop enable)			 */
+	/* ([2] = 1 fading_enable)		 */
+	/* ([3] = 1 PD_enable)			 */
+	/* ([4] = 1 alpha cal_mode_sel)	 */
+	/* ([5] = 1 dither_enable)		 */
+	/* ([6] = 1 gradient fill mode sel) */
+	/* ([7] = 1 AA_enable)			 */
+	uint16_t alpha_rop_flag;
+
+	/* 0 nearst / 1 bilnear / 2 bicubic */
+	uint8_t scale_mode;
+
+	/* color key max */
+	uint32_t color_key_max;
+	/* color key min */
+	uint32_t color_key_min;
+
+	/* foreground color */
+	uint32_t fg_color;
+	/* background color */
+	uint32_t bg_color;
+
+	/* color fill use gradient */
+	struct rga_color_fill_t gr_color;
+
+	struct rga_line_draw_t line_draw_info;
+
+	struct rga_fading_t fading;
+
+	/* porter duff alpha mode sel */
+	uint8_t PD_mode;
+
+	/* global alpha value */
+	uint8_t alpha_global_value;
+
+	/* rop2/3/4 code scan from rop code table*/
+	uint16_t rop_code;
+
+	/* [2] 0 blur 1 sharp / [1:0] filter_type*/
+	uint8_t bsfilter_flag;
+
+	/* (enum) color palette 0/1bpp, 1/2bpp 2/4bpp 3/8bpp*/
+	uint8_t palette_mode;
+
+	/* (enum) BT.601 MPEG / BT.601 JPEG / BT.709 */
+	uint8_t yuv2rgb_mode;
+
+	/* 0/big endian 1/little endian*/
+	uint8_t endian_mode;
+
+	/* (enum) rotate mode */
+	/* 0x0,	 no rotate */
+	/* 0x1,	 rotate	 */
+	/* 0x2,	 x_mirror */
+	/* 0x3,	 y_mirror */
+	uint8_t rotate_mode;
+
+	/* 0 solid color / 1 pattern color */
+	uint8_t color_fill_mode;
+
+	/* mmu information */
+	struct rga_mmu_t mmu_info;
+
+	/* ([0~1] alpha mode)			*/
+	/* ([2~3] rop mode)			*/
+	/* ([4] zero mode en)		 */
+	/* ([5] dst alpha mode)	 */
+	/* ([6] alpha output mode sel) 0 src / 1 dst*/
+	uint8_t alpha_rop_mode;
+
+	uint8_t src_trans_mode;
+
+	uint8_t dither_mode;
+
+	/* full color space convert */
+	struct rga_full_csc full_csc;
+
+	int32_t in_fence_fd;
+	uint8_t core;
+	uint8_t priority;
+	int32_t out_fence_fd;
+
+	uint8_t handle_flag;
+
+	/* RGA2 1106 add */
+	struct rga_mosaic_info mosaic_info;
+
+	uint8_t uvhds_mode;
+	uint8_t uvvds_mode;
+
+	struct rga_osd_info osd_info;
+
+	struct rga_pre_intr_info pre_intr_info;
+
+	uint8_t reservr[59];
+};
+#endif /*_RGA_DRIVER_H_*/
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 1cca4b6e7d..e3e51d9973 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -26,6 +26,7 @@
 #include <time.h>
 #include <unistd.h>
 #include <sys/time.h>
+#include <fcntl.h>
 
 #include "avcodec.h"
 #include "codec_internal.h"
@@ -40,6 +41,7 @@
 #include "libavutil/imgutils.h"
 #include "libavutil/log.h"
 #include "libyuv/planar_functions.h"
+#include "rga.h"
 
 // HACK: Older BSP kernel use NA12 for NV15.
 #ifndef DRM_FORMAT_NV15 // fourcc_code('N', 'V', '1', '5')
@@ -55,6 +57,7 @@ typedef struct {
 
     int8_t eos;
     int8_t draining;
+    int8_t softconvert;
 
     AVPacket packet;
     AVBufferRef *frames_ref;
@@ -66,6 +69,8 @@ typedef struct {
     uint64_t frames;
 
     char sync;
+
+    int rga_fd;
 } RKMPPDecoder;
 
 typedef struct {
@@ -114,6 +119,16 @@ static uint32_t rkmpp_get_avformat(MppFrameFormat mppformat)
     }
 }
 
+static uint32_t rkmpp_get_rgaformat(MppFrameFormat mppformat)
+{
+    switch (mppformat & MPP_FRAME_FMT_MASK) {
+    case MPP_FMT_YUV420SP:          return RGA_FORMAT_YCbCr_420_SP;
+    case MPP_FMT_YUV420SP_10BIT:    return RGA_FORMAT_YCbCr_420_SP_10B;
+    case MPP_FMT_YUV422SP:          return RGA_FORMAT_YCbCr_422_SP;
+    default:                        return RGA_FORMAT_UNKNOWN;
+    }
+}
+
 static int rkmpp_close_decoder(AVCodecContext *avctx)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
@@ -140,6 +155,11 @@ static void rkmpp_release_decoder(void *opaque, uint8_t *data)
         decoder->frame_group = NULL;
     }
 
+    if (decoder->rga_fd) {
+        close(decoder->rga_fd);
+        decoder->rga_fd = 0;
+    }
+
     av_buffer_unref(&decoder->frames_ref);
     av_buffer_unref(&decoder->device_ref);
 
@@ -244,6 +264,11 @@ static int rkmpp_init_decoder(AVCodecContext *avctx)
        goto fail;
     }
 
+    decoder->rga_fd = open("/dev/rga", O_RDWR);
+    if (decoder->rga_fd < 0) {
+       av_log(avctx, AV_LOG_WARNING, "Failed to open RGA, Falling back to libyuv\n");
+    }
+
     ret = decoder->mpi->control(decoder->ctx, MPP_DEC_SET_EXT_BUF_GROUP, decoder->frame_group);
     if (ret) {
         av_log(avctx, AV_LOG_ERROR, "Failed to assign buffer group (code = %d)\n", ret);
@@ -300,14 +325,67 @@ static void rkmpp_release_buffer(void *opaque, uint8_t *data)
 static int rkmpp_convert_frame(AVCodecContext *avctx, AVFrame *frame,
                                MppFrame mppframe, MppBuffer buffer)
 {
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+
     char *src = mpp_buffer_get_ptr(buffer);
+    char *dst_y = frame->data[0];
     char *dst_u = frame->data[1];
     char *dst_v = frame->data[2];
+    enum rga_surf_format rgaformat = rkmpp_get_rgaformat(mpp_frame_get_fmt(mppframe));
+    int width = mpp_frame_get_width(mppframe);
+    int height = mpp_frame_get_height(mppframe);
     int hstride = mpp_frame_get_hor_stride(mppframe);
     int vstride = mpp_frame_get_ver_stride(mppframe);
+    int y_pitch = frame->linesize[0];
     int u_pitch = frame->linesize[1];
     int v_pitch = frame->linesize[2];
 
+    int ret;
+
+    int dst_height = (dst_u - dst_y) / y_pitch;
+
+    if (decoder->softconvert || decoder->rga_fd < 0)
+        goto softconvert;
+
+    struct rga_req req = {
+        .src = {
+            .yrgb_addr = mpp_buffer_get_fd(buffer),
+            .v_addr = hstride * vstride,
+            .format = rgaformat,
+            .act_w = width,
+            .act_h = height,
+            .vir_w = hstride,
+            .vir_h = vstride,
+            .rd_mode = RGA_RASTER_MODE,
+        },
+        .dst = {
+            .uv_addr = (uintptr_t) dst_y,
+            .v_addr = (uintptr_t) dst_u,
+            .format = RGA_FORMAT_YCbCr_420_P,
+            .act_w = width,
+            .act_h = height,
+            .vir_w = y_pitch,
+            .vir_h = dst_height,
+            .rd_mode = RGA_RASTER_MODE,
+        },
+        .mmu_info = {
+            .mmu_en = 1,
+            .mmu_flag = 0x80000521,
+        },
+    };
+
+    ret = ioctl(decoder->rga_fd, RGA_BLIT_SYNC, &req);
+    if (ret < 0){
+        decoder->softconvert = 1;
+        av_log(avctx, AV_LOG_WARNING, "RGA failed with code %d, falling back to soft conversion of uv planes\n");
+        goto softconvert;
+    }
+
+    rkmpp_release_buffer(mppframe, NULL);
+    return 0;
+
+softconvert:
     //data[0] points to buf[1] where the mppbuffer is referenced for y plane
     //so that we can still use y plane without extra copies
     //data[1,2] points to allready allocated AVBuffer Pool (buf[0]), we will convert to
@@ -320,7 +398,6 @@ static int rkmpp_convert_frame(AVCodecContext *avctx, AVFrame *frame,
         return AVERROR(ENOMEM);
     }
     frame->linesize[0] = hstride;
-    av_log(avctx, AV_LOG_WARNING, "Doing software conversion for uv planes\n");
 
     src += hstride * vstride;
 
@@ -686,6 +763,7 @@ static void rkmpp_flush(AVCodecContext *avctx)
 
     decoder->eos = 0;
     decoder->draining = 0;
+    decoder->softconvert = 0;
     decoder->last_fps_time = decoder->frames = 0;
 
     av_packet_unref(&decoder->packet);
-- 
2.40.0


From 21644b8342b95bc75b2b2b4e1cddd37ab8668283 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Tue, 18 Apr 2023 23:20:13 +0200
Subject: [PATCH 19/24] rework receive frame without any loop and more
 statefull flow remove draining flags which is no more necessary with the new
 flow remove sync mode, this is useless

---
 libavcodec/rkmppdec.c | 114 +++++++++++++-----------------------------
 1 file changed, 36 insertions(+), 78 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index e3e51d9973..bd87d74e39 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -56,7 +56,6 @@ typedef struct {
     MppBufferGroup frame_group;
 
     int8_t eos;
-    int8_t draining;
     int8_t softconvert;
 
     AVPacket packet;
@@ -68,8 +67,6 @@ typedef struct {
     uint64_t last_fps_time;
     uint64_t frames;
 
-    char sync;
-
     int rga_fd;
 } RKMPPDecoder;
 
@@ -166,33 +163,6 @@ static void rkmpp_release_decoder(void *opaque, uint8_t *data)
     av_free(decoder);
 }
 
-static int rkmpp_prepare_decoder(AVCodecContext *avctx)
-{
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    MppPacket packet;
-    int ret;
-
-    // HACK: somehow MPP cannot handle extra data for AV1
-    if (avctx->extradata_size && avctx->codec_id != AV_CODEC_ID_AV1) {
-        ret = mpp_packet_init(&packet, avctx->extradata, avctx->extradata_size);
-        if (ret < 0)
-            return AVERROR_UNKNOWN;
-        ret = decoder->mpi->decode_put_packet(decoder->ctx, packet);
-        mpp_packet_deinit(&packet);
-        if (ret < 0)
-            return AVERROR_UNKNOWN;
-    }
-
-    if (getenv("FFMPEG_RKMPP_SYNC")) {
-        // wait for decode result after feeding any packets
-        decoder->sync = 1;
-        ret = 1;
-        decoder->mpi->control(decoder->ctx, MPP_DEC_SET_IMMEDIATE_OUT, &ret);
-    }
-    return 0;
-}
-
 static int rkmpp_init_decoder(AVCodecContext *avctx)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
@@ -278,7 +248,6 @@ static int rkmpp_init_decoder(AVCodecContext *avctx)
 
     decoder->mpi->control(decoder->ctx, MPP_DEC_SET_DISABLE_ERROR, NULL);
 
-    ret = rkmpp_prepare_decoder(avctx);
     if (ret < 0) {
         av_log(avctx, AV_LOG_ERROR, "Failed to prepare decoder (code = %d)\n", ret);
         goto fail;
@@ -378,7 +347,7 @@ static int rkmpp_convert_frame(AVCodecContext *avctx, AVFrame *frame,
     ret = ioctl(decoder->rga_fd, RGA_BLIT_SYNC, &req);
     if (ret < 0){
         decoder->softconvert = 1;
-        av_log(avctx, AV_LOG_WARNING, "RGA failed with code %d, falling back to soft conversion of uv planes\n");
+        av_log(avctx, AV_LOG_WARNING, "RGA failed with code %d, falling back to soft conversion of uv planes\n", ret);
         goto softconvert;
     }
 
@@ -645,10 +614,6 @@ static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *packet)
     int64_t pts = packet->pts;
     int ret;
 
-    // avoid sending new data after EOS
-    if (decoder->draining)
-        return AVERROR_EOF;
-
     if (!pts || pts == AV_NOPTS_VALUE)
         pts = avctx->reordered_opaque;
 
@@ -692,8 +657,6 @@ static int rkmpp_send_eos(AVCodecContext *avctx)
     } while (ret != MPP_OK);
     mpp_packet_deinit(&mpkt);
 
-    decoder->draining = 1;
-
     return 0;
 }
 
@@ -703,51 +666,48 @@ static int rkmpp_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
     AVPacket *packet = &decoder->packet;
     int ret;
+    int gettimeout = MPP_TIMEOUT_NON_BLOCK;;
 
-    // no more frames after EOS
     if (decoder->eos)
         return AVERROR_EOF;
 
-    // draining remain frames
-    if (decoder->draining)
-        return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
+    // get packet if not already available from previous iteration
+    if (!packet->size){
+        ret = ff_decode_get_packet(avctx, packet);
+        if (ret == AVERROR_EOF) {
+            av_log(avctx, AV_LOG_DEBUG, "Draining.\n");
+            // send EOS and start draining
+            rkmpp_send_eos(avctx);
+            // we can get all the decoder backlog blocking here
+            gettimeout = MPP_TIMEOUT_BLOCK;
+        }
+    }
 
-    while (1) {
-        if (!packet->size) {
-            ret = ff_decode_get_packet(avctx, packet);
-            if (ret == AVERROR_EOF) {
-                av_log(avctx, AV_LOG_DEBUG, "End of stream.\n");
-                // send EOS and start draining
-                rkmpp_send_eos(avctx);
-                return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
-            } else if (ret == AVERROR(EAGAIN)) {
-                // not blocking so that we can feed new data ASAP
-                return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_NON_BLOCK);
-            } else if (ret < 0) {
-                av_log(avctx, AV_LOG_ERROR, "Failed to get packet (code = %d)\n", ret);
-                return ret;
-            }
+    // when there are packets available to push to decoder
+    if (packet->size) {
+        ret = rkmpp_send_packet(avctx, packet);
+        if (ret == AVERROR(EAGAIN)) {
+            // decoder input buffer is full, no need to poll packets unless we receive a frame
+            gettimeout = MPP_TIMEOUT_BLOCK;
+        } else if (ret < 0) {
+            // error handling
+            av_log(avctx, AV_LOG_ERROR, "Failed to send data (code = %d)\n", ret);
+            return ret;
         } else {
-            // send pending data to decoder
-            ret = rkmpp_send_packet(avctx, packet);
-            if (ret == AVERROR(EAGAIN)) {
-                // some streams might need more packets to start returning frames
-                ret = rkmpp_get_frame(avctx, frame, 1);
-                if (ret != AVERROR(EAGAIN))
-                    return ret;
-            } else if (ret < 0) {
-                av_log(avctx, AV_LOG_ERROR, "Failed to send data (code = %d)\n", ret);
-                return ret;
-            } else {
-                av_packet_unref(packet);
-                packet->size = 0;
-
-                // blocked waiting for decode result
-                if (decoder->sync)
-                    return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
-            }
+            // successful decoder write
+            av_packet_unref(packet);
         }
     }
+
+    // always try to consume decoder because it is more likely to be full rather than the packet inputs
+    // decoder is the bottleneck here
+     ret = rkmpp_get_frame(avctx, frame, gettimeout);
+    if (ret == AVERROR_EOF) {
+        av_log(avctx, AV_LOG_DEBUG, "End of Stream.\n");
+        return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
+    }
+
+    return ret;
 }
 
 static void rkmpp_flush(AVCodecContext *avctx)
@@ -759,11 +719,9 @@ static void rkmpp_flush(AVCodecContext *avctx)
 
     decoder->mpi->reset(decoder->ctx);
 
-    rkmpp_prepare_decoder(avctx);
-
     decoder->eos = 0;
-    decoder->draining = 0;
     decoder->softconvert = 0;
+
     decoder->last_fps_time = decoder->frames = 0;
 
     av_packet_unref(&decoder->packet);
-- 
2.40.0


From f46c90307798f98cdf2b0d15d5b8905e4db83cf6 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Fri, 28 Apr 2023 23:28:14 +0200
Subject: [PATCH 20/24] rework on flow nv12 output support without rga hdr to
 sdr conversion support with rga3

---
 libavcodec/rkmppdec.c | 541 ++++++++++++++++++++++++------------------
 1 file changed, 314 insertions(+), 227 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index bd87d74e39..f71511d0d0 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -41,6 +41,8 @@
 #include "libavutil/imgutils.h"
 #include "libavutil/log.h"
 #include "libyuv/planar_functions.h"
+#include "libyuv/scale_uv.h"
+#include "libyuv/scale.h"
 #include "rga.h"
 
 // HACK: Older BSP kernel use NA12 for NV15.
@@ -48,7 +50,7 @@
 #define DRM_FORMAT_NV15 fourcc_code('N', 'A', '1', '2')
 #endif
 
-#define FPS_UPDATE_INTERVAL     120
+#define FPS_UPDATE_INTERVAL     60
 
 typedef struct {
     MppCtx ctx;
@@ -56,7 +58,6 @@ typedef struct {
     MppBufferGroup frame_group;
 
     int8_t eos;
-    int8_t softconvert;
 
     AVPacket packet;
     AVBufferRef *frames_ref;
@@ -67,7 +68,16 @@ typedef struct {
     uint64_t last_fps_time;
     uint64_t frames;
 
+    uint32_t mpp_format;
+    uint32_t rga_informat;
+    uint32_t rga_outformat;
+    uint32_t drm_format;
+    uint32_t sw_format;
     int rga_fd;
+    int8_t rgafbc;
+    int8_t norga;
+    int (*buffer_callback)(struct AVCodecContext *avctx, struct AVFrame *frame, MppFrame mppframe);
+
 } RKMPPDecoder;
 
 typedef struct {
@@ -96,36 +106,6 @@ static MppCodingType rkmpp_get_codingtype(AVCodecContext *avctx)
     }
 }
 
-static uint32_t rkmpp_get_frameformat(MppFrameFormat mppformat)
-{
-    switch (mppformat & MPP_FRAME_FMT_MASK) {
-    case MPP_FMT_YUV420SP:          return DRM_FORMAT_NV12;
-    case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_NV15;
-    case MPP_FMT_YUV422SP:          return DRM_FORMAT_NV16;
-    default:                        return 0;
-    }
-}
-
-static uint32_t rkmpp_get_avformat(MppFrameFormat mppformat)
-{
-    switch (mppformat & MPP_FRAME_FMT_MASK) {
-    case MPP_FMT_YUV420SP:          return AV_PIX_FMT_NV12;
-    case MPP_FMT_YUV420SP_10BIT:    return AV_PIX_FMT_NONE;
-    case MPP_FMT_YUV422SP:          return AV_PIX_FMT_NV16;
-    default:                        return 0;
-    }
-}
-
-static uint32_t rkmpp_get_rgaformat(MppFrameFormat mppformat)
-{
-    switch (mppformat & MPP_FRAME_FMT_MASK) {
-    case MPP_FMT_YUV420SP:          return RGA_FORMAT_YCbCr_420_SP;
-    case MPP_FMT_YUV420SP_10BIT:    return RGA_FORMAT_YCbCr_420_SP_10B;
-    case MPP_FMT_YUV422SP:          return RGA_FORMAT_YCbCr_422_SP;
-    default:                        return RGA_FORMAT_UNKNOWN;
-    }
-}
-
 static int rkmpp_close_decoder(AVCodecContext *avctx)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
@@ -163,6 +143,141 @@ static void rkmpp_release_decoder(void *opaque, uint8_t *data)
     av_free(decoder);
 }
 
+static void rkmpp_release_drmbuf(void *opaque, uint8_t *data)
+{
+    AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)data;
+    AVBufferRef *framecontextref = (AVBufferRef *)opaque;
+    RKMPPFrameContext *framecontext = (RKMPPFrameContext *)framecontextref->data;
+
+    mpp_frame_deinit(&framecontext->frame);
+    av_buffer_unref(&framecontext->decoder_ref);
+    av_buffer_unref(&framecontextref);
+
+    av_free(desc);
+}
+
+static void rkmpp_release_buf(void *opaque, uint8_t *data)
+{
+    MppFrame mppframe = opaque;
+    mpp_frame_deinit(&mppframe);
+}
+
+static int rkmpp_set_nv12_buf(AVCodecContext *avctx, AVFrame *frame, MppFrame mppframe)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+
+    MppBuffer buffer = mpp_frame_get_buffer(mppframe);
+    int width = mpp_frame_get_width(mppframe);
+    int hstride = mpp_frame_get_hor_stride(mppframe);
+    int vstride = mpp_frame_get_ver_stride(mppframe);
+
+    frame->data[0] = mpp_buffer_get_ptr(buffer); // y
+    frame->data[1] = frame->data[0] + hstride * vstride; // u + v
+    frame->extended_data = frame->data;
+
+       frame->linesize[0] = hstride;
+       frame->linesize[1] = hstride;
+
+       frame->buf[0] = av_buffer_create(frame->data[0], mpp_buffer_get_size(buffer),
+            rkmpp_release_buf, mppframe,
+            AV_BUFFER_FLAG_READONLY);
+    if (!frame->buf[0]) {
+        return AVERROR(ENOMEM);
+    }
+
+    return 0;
+}
+
+static int rkmpp_rga_convert_buf(AVCodecContext *avctx, AVFrame *frame, MppFrame mppframe)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+
+    MppBuffer buffer = mpp_frame_get_buffer(mppframe);
+    char *src = mpp_buffer_get_ptr(buffer);
+    int width = mpp_frame_get_width(mppframe);
+    int height = mpp_frame_get_height(mppframe);
+    int hstride = mpp_frame_get_hor_stride(mppframe);
+    int vstride = mpp_frame_get_ver_stride(mppframe);
+    int ret;
+
+    ret = ff_get_buffer(avctx, frame, 0);
+    if (ret < 0)
+        return ret;
+
+    if (!decoder->norga && decoder->rga_fd >= 0){
+        struct rga_req req = {
+            .src = {
+                .yrgb_addr = mpp_buffer_get_fd(buffer),
+                .v_addr = hstride * vstride,
+                .format = decoder->rga_informat,
+                .act_w = width,
+                .act_h = height,
+                .vir_w = hstride,
+                .vir_h = vstride,
+                .rd_mode = RGA_RASTER_MODE,
+            },
+            .dst = {
+                .uv_addr = (uintptr_t) frame->data[0],
+                .v_addr = (uintptr_t) frame->data[1],
+                .format = decoder->rga_outformat,
+                .act_w = width,
+                .act_h = height,
+                .vir_w = frame->linesize[0],
+                .vir_h = (frame->data[1] - frame->data[0]) / frame->linesize[0],
+                .rd_mode = RGA_RASTER_MODE,
+            },
+            .mmu_info = {
+                .mmu_en = 1,
+                .mmu_flag = 0x80000521,
+            },
+        };
+
+        ret = ioctl(decoder->rga_fd, RGA_BLIT_SYNC, &req);
+        if (ret < 0){
+            decoder->norga = 1;
+            av_log(avctx, AV_LOG_WARNING, "RGA failed with code %d, falling back to soft conversion\n", ret);
+        } else {
+            rkmpp_release_buf(mppframe, NULL);
+            return 0;
+        }
+    }
+
+    if ((decoder->norga || decoder->rga_fd < 0) && decoder->rga_outformat == RGA_FORMAT_YCbCr_420_P){
+        //data[0] points to buf[1] where the mppbuffer is referenced for y plane
+        //so that we can still use y plane without extra copies
+        //data[1,2] points to allready allocated AVBuffer Pool (buf[0]), we will convert to
+        //that buffer only u+v planes, which is half the size operation
+        frame->data[0] = mpp_buffer_get_ptr(buffer);
+        frame->buf[1] = av_buffer_create(frame->data[0], mpp_buffer_get_size(buffer),
+                rkmpp_release_buf, mppframe,
+                AV_BUFFER_FLAG_READONLY);
+        if (!frame->buf[1]) {
+            return AVERROR(ENOMEM);
+        }
+        frame->linesize[0] = hstride;
+
+        src += hstride * vstride;
+        if(decoder->rga_informat == RGA_FORMAT_YCbCr_422_SP){
+        	/* In case the input format has 4:2:2 UV planes, it will have double the size of 4:2:0 UV Planes
+        	 * Therefore we scale them to the half the size to the unused FFbuffer's Y Plane (We are using MPP 's Y)
+        	 * Then we convert to Planar in the next step. Normally it should be possible to this in 1 step
+        	 * But i can not find a way to do it in 1 step using libyuv. But thats fine enough
+        	 */
+			UVScale(src, hstride, frame->width, frame->height,
+					frame->buf[0]->data, hstride,
+					(frame->width + 1) >> 1, (frame->height + 1) >> 1, kFilterNone);
+			src = frame->buf[0]->data;
+        }
+        SplitUVPlane(src, hstride, frame->data[1], frame->linesize[1], frame->data[2], frame->linesize[2],
+                (frame->width + 1) >> 1, (frame->height + 1) >> 1);
+        return 0;
+    }
+
+    return AVERROR_UNKNOWN;
+}
+
 static int rkmpp_init_decoder(AVCodecContext *avctx)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
@@ -234,9 +349,14 @@ static int rkmpp_init_decoder(AVCodecContext *avctx)
        goto fail;
     }
 
-    decoder->rga_fd = open("/dev/rga", O_RDWR);
-    if (decoder->rga_fd < 0) {
-       av_log(avctx, AV_LOG_WARNING, "Failed to open RGA, Falling back to libyuv\n");
+    env = getenv("FFMPEG_RKMPP_NORGA");
+    if (env != NULL)
+        decoder->rga_fd = -1;
+    else {
+        decoder->rga_fd = open("/dev/rga", O_RDWR);
+        if (decoder->rga_fd < 0) {
+           av_log(avctx, AV_LOG_WARNING, "Failed to open RGA, Falling back to libyuv\n");
+        }
     }
 
     ret = decoder->mpi->control(decoder->ctx, MPP_DEC_SET_EXT_BUF_GROUP, decoder->frame_group);
@@ -272,109 +392,6 @@ fail:
     return ret;
 }
 
-static void rkmpp_release_frame(void *opaque, uint8_t *data)
-{
-    AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)data;
-    AVBufferRef *framecontextref = (AVBufferRef *)opaque;
-    RKMPPFrameContext *framecontext = (RKMPPFrameContext *)framecontextref->data;
-
-    mpp_frame_deinit(&framecontext->frame);
-    av_buffer_unref(&framecontext->decoder_ref);
-    av_buffer_unref(&framecontextref);
-
-    av_free(desc);
-}
-
-static void rkmpp_release_buffer(void *opaque, uint8_t *data)
-{
-    MppFrame mppframe = opaque;
-    mpp_frame_deinit(&mppframe);
-}
-
-static int rkmpp_convert_frame(AVCodecContext *avctx, AVFrame *frame,
-                               MppFrame mppframe, MppBuffer buffer)
-{
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-
-    char *src = mpp_buffer_get_ptr(buffer);
-    char *dst_y = frame->data[0];
-    char *dst_u = frame->data[1];
-    char *dst_v = frame->data[2];
-    enum rga_surf_format rgaformat = rkmpp_get_rgaformat(mpp_frame_get_fmt(mppframe));
-    int width = mpp_frame_get_width(mppframe);
-    int height = mpp_frame_get_height(mppframe);
-    int hstride = mpp_frame_get_hor_stride(mppframe);
-    int vstride = mpp_frame_get_ver_stride(mppframe);
-    int y_pitch = frame->linesize[0];
-    int u_pitch = frame->linesize[1];
-    int v_pitch = frame->linesize[2];
-
-    int ret;
-
-    int dst_height = (dst_u - dst_y) / y_pitch;
-
-    if (decoder->softconvert || decoder->rga_fd < 0)
-        goto softconvert;
-
-    struct rga_req req = {
-        .src = {
-            .yrgb_addr = mpp_buffer_get_fd(buffer),
-            .v_addr = hstride * vstride,
-            .format = rgaformat,
-            .act_w = width,
-            .act_h = height,
-            .vir_w = hstride,
-            .vir_h = vstride,
-            .rd_mode = RGA_RASTER_MODE,
-        },
-        .dst = {
-            .uv_addr = (uintptr_t) dst_y,
-            .v_addr = (uintptr_t) dst_u,
-            .format = RGA_FORMAT_YCbCr_420_P,
-            .act_w = width,
-            .act_h = height,
-            .vir_w = y_pitch,
-            .vir_h = dst_height,
-            .rd_mode = RGA_RASTER_MODE,
-        },
-        .mmu_info = {
-            .mmu_en = 1,
-            .mmu_flag = 0x80000521,
-        },
-    };
-
-    ret = ioctl(decoder->rga_fd, RGA_BLIT_SYNC, &req);
-    if (ret < 0){
-        decoder->softconvert = 1;
-        av_log(avctx, AV_LOG_WARNING, "RGA failed with code %d, falling back to soft conversion of uv planes\n", ret);
-        goto softconvert;
-    }
-
-    rkmpp_release_buffer(mppframe, NULL);
-    return 0;
-
-softconvert:
-    //data[0] points to buf[1] where the mppbuffer is referenced for y plane
-    //so that we can still use y plane without extra copies
-    //data[1,2] points to allready allocated AVBuffer Pool (buf[0]), we will convert to
-    //that buffer only u+v planes, which is half the size operation
-    frame->data[0] = mpp_buffer_get_ptr(buffer);
-    frame->buf[1] = av_buffer_create(frame->data[0], mpp_buffer_get_size(buffer),
-            rkmpp_release_buffer, mppframe,
-            AV_BUFFER_FLAG_READONLY);
-    if (!frame->buf[1]) {
-        return AVERROR(ENOMEM);
-    }
-    frame->linesize[0] = hstride;
-
-    src += hstride * vstride;
-
-    SplitUVPlane(src, hstride, dst_u, u_pitch, dst_v, v_pitch,
-            (frame->width + 1) >> 1, (frame->height + 1) >> 1);
-    return 0;
-}
-
 static void rkmpp_update_fps(AVCodecContext *avctx)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
@@ -405,20 +422,151 @@ static void rkmpp_update_fps(AVCodecContext *avctx)
            fps, decoder->frames);
 }
 
-static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
+static int rkmpp_set_drm_buf(AVCodecContext *avctx, AVFrame *frame, MppFrame mppframe)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
     RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
     RKMPPFrameContext *framecontext = NULL;
     AVBufferRef *framecontextref = NULL;
+    AVDRMFrameDescriptor *desc = NULL;
+    AVDRMLayerDescriptor *layer = NULL;
+    MppBuffer buffer = mpp_frame_get_buffer(mppframe);
     int ret;
+
+    desc = av_mallocz(sizeof(AVDRMFrameDescriptor));
+    if (!desc) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    desc->nb_objects = 1;
+    desc->objects[0].fd = mpp_buffer_get_fd(buffer);
+    desc->objects[0].size = mpp_buffer_get_size(buffer);
+
+    desc->nb_layers = 1;
+    layer = &desc->layers[0];
+    layer->format = decoder->drm_format;
+    layer->nb_planes = 2;
+
+    layer->planes[0].object_index = 0;
+    layer->planes[0].offset = 0;
+    layer->planes[0].pitch = mpp_frame_get_hor_stride(mppframe);
+
+    layer->planes[1].object_index = 0;
+    layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mppframe);
+    layer->planes[1].pitch = layer->planes[0].pitch;
+
+    // we also allocate a struct in buf[0] that will allow to hold additionnal information
+    // for releasing properly MPP frames and decoder
+    framecontextref = av_buffer_allocz(sizeof(*framecontext));
+    if (!framecontextref) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    // MPP decoder needs to be closed only when all frames have been released.
+    framecontext = (RKMPPFrameContext *)framecontextref->data;
+    framecontext->decoder_ref = av_buffer_ref(rk_context->decoder_ref);
+    framecontext->frame = mppframe;
+
+    frame->data[0]  = (uint8_t *)desc;
+    frame->buf[0]   = av_buffer_create((uint8_t *)desc, sizeof(*desc), rkmpp_release_drmbuf,
+                                       framecontextref, AV_BUFFER_FLAG_READONLY);
+
+    if (!frame->buf[0]) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    frame->hw_frames_ctx = av_buffer_ref(decoder->frames_ref);
+    if (!frame->hw_frames_ctx) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    return 0;
+
+fail:
+    if (framecontext)
+        av_buffer_unref(&framecontext->decoder_ref);
+
+    if (framecontextref)
+        av_buffer_unref(&framecontextref);
+
+    if (desc)
+        av_free(desc);
+
+    return ret;
+}
+
+static int set_buffer_callback(RKMPPDecoder *decoder, AVCodecContext *avctx){
+    if (avctx->pix_fmt == AV_PIX_FMT_DRM_PRIME){
+        decoder->buffer_callback = rkmpp_set_drm_buf;
+        switch(decoder->mpp_format){
+        case MPP_FMT_YUV420SP_10BIT:
+            decoder->drm_format = DRM_FORMAT_NV15;
+            decoder->sw_format = AV_PIX_FMT_NONE;
+            av_log(avctx, AV_LOG_INFO, "Decoder is set to use DRMPrime with NV15.\n");
+            return 0;
+        case MPP_FMT_YUV420SP:
+            decoder->drm_format = DRM_FORMAT_NV12;
+            decoder->sw_format = AV_PIX_FMT_NV12;
+            av_log(avctx, AV_LOG_INFO, "Decoder is set to use DRMPrime with NV12.\n");
+            return 0;
+        case MPP_FMT_YUV422SP:
+            decoder->drm_format = DRM_FORMAT_NV16;
+            decoder->sw_format = AV_PIX_FMT_NV16;
+            av_log(avctx, AV_LOG_INFO, "Decoder is set to use DRMPrime with NV16.\n");
+            return 0;
+        }
+    } else if(avctx->pix_fmt == AV_PIX_FMT_NV12){
+        decoder->rga_outformat = RGA_FORMAT_YCbCr_420_SP;
+        switch(decoder->mpp_format){
+        case MPP_FMT_YUV420SP_10BIT:
+            decoder->rga_informat = RGA_FORMAT_YCbCr_420_SP_10B;
+            decoder->buffer_callback = rkmpp_rga_convert_buf;
+            av_log(avctx, AV_LOG_INFO, "Decoder is set to use AVBuffer with NV15->NV12 conversion through RGA3.\n");
+            return 0;
+        case MPP_FMT_YUV420SP:
+            decoder->buffer_callback = rkmpp_set_nv12_buf;
+            av_log(avctx, AV_LOG_INFO, "Decoder is set to use MppBuffer with NV12.\n");
+            return 0;
+        case MPP_FMT_YUV422SP:
+            decoder->rga_informat = RGA_FORMAT_YCbCr_422_SP;
+            decoder->buffer_callback = rkmpp_rga_convert_buf;
+            av_log(avctx, AV_LOG_INFO, "Decoder is set to use AVBuffer with NV16->NV12 conversion through RGA3.\n");
+            return 0;
+        }
+    } else if (avctx->pix_fmt == AV_PIX_FMT_YUV420P){
+        decoder->rga_outformat = RGA_FORMAT_YCbCr_420_P;
+        switch(decoder->mpp_format){
+        case MPP_FMT_YUV420SP:
+            decoder->rga_informat = RGA_FORMAT_YCbCr_420_SP;
+            break;
+        case MPP_FMT_YUV422SP:
+            decoder->rga_informat = RGA_FORMAT_YCbCr_422_SP;
+            break;
+        }
+        if(decoder->rga_informat){
+			decoder->buffer_callback = rkmpp_rga_convert_buf;
+			if(decoder->norga || decoder->rga_fd < 0)
+				av_log(avctx, AV_LOG_INFO, "Decoder is set to use AVBuffer with NV12->YUV420P conversion through libyuv.\n");
+			else
+				av_log(avctx, AV_LOG_INFO, "Decoder is set to use AVBuffer with NV12->YUV420P conversion through RGA2.\n");
+			return 0;
+        }
+    }
+    av_log(avctx, AV_LOG_ERROR, "Unknown MPP format:%d and AVFormat:%d.\n", decoder->mpp_format, avctx->pix_fmt);
+    return AVERROR_UNKNOWN;
+}
+
+static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
     MppFrame mppframe = NULL;
     MppBuffer buffer = NULL;
-    AVDRMFrameDescriptor *desc = NULL;
-    AVDRMLayerDescriptor *layer = NULL;
-    int mode;
-    MppFrameFormat mppformat;
-    uint32_t drmformat;
+    int ret, mode;
 
     // should not provide any frame after EOS
     if (decoder->eos)
@@ -458,6 +606,7 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
 
     if (mpp_frame_get_info_change(mppframe)) {
         AVHWFramesContext *hwframes;
+        decoder->mpp_format = mpp_frame_get_fmt(mppframe) & MPP_FRAME_FMT_MASK;
 
         av_log(avctx, AV_LOG_INFO, "Decoder noticed an info change (%dx%d), format=%d\n",
                (int)mpp_frame_get_width(mppframe), (int)mpp_frame_get_height(mppframe),
@@ -474,6 +623,10 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
         decoder->mpi->control(decoder->ctx, MPP_DEC_SET_FRAME_INFO, (MppParam) mppframe);
         decoder->mpi->control(decoder->ctx, MPP_DEC_SET_INFO_CHANGE_READY, NULL);
 
+        ret = set_buffer_callback(decoder, avctx);
+        if (ret)
+            goto fail;
+
         av_buffer_unref(&decoder->frames_ref);
 
         decoder->frames_ref = av_hwframe_ctx_alloc(decoder->device_ref);
@@ -482,11 +635,9 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
             goto fail;
         }
 
-        mppformat = mpp_frame_get_fmt(mppframe);
-
         hwframes = (AVHWFramesContext*)decoder->frames_ref->data;
         hwframes->format    = AV_PIX_FMT_DRM_PRIME;
-        hwframes->sw_format = rkmpp_get_avformat(mppformat);
+        hwframes->sw_format = decoder->sw_format;
         hwframes->width     = avctx->width;
         hwframes->height    = avctx->height;
         ret = av_hwframe_ctx_init(decoder->frames_ref);
@@ -509,10 +660,17 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
 
     rkmpp_update_fps(avctx);
 
-    if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME) {
-        ret = ff_get_buffer(avctx, frame, 0);
-        if (ret < 0)
-            goto fail;
+    if(!decoder->buffer_callback){
+    	ret = AVERROR_UNKNOWN;
+        av_log(avctx, AV_LOG_ERROR, "Decoder has no valid buffer_callback\n");
+        goto fail;
+    }
+
+    ret = decoder->buffer_callback(avctx, frame, mppframe);
+
+    if(ret){
+        av_log(avctx, AV_LOG_ERROR, "Failed set frame buffer (code = %d)\n", ret);
+        goto fail;
     }
 
     // setup general frame fields
@@ -530,79 +688,11 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     frame->interlaced_frame = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_DEINTERLACED);
     frame->top_field_first  = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST);
 
-    if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME) {
-        return rkmpp_convert_frame(avctx, frame, mppframe, buffer);
-    }
-
-    mppformat = mpp_frame_get_fmt(mppframe);
-    drmformat = rkmpp_get_frameformat(mppformat);
-
-    desc = av_mallocz(sizeof(AVDRMFrameDescriptor));
-    if (!desc) {
-        ret = AVERROR(ENOMEM);
-        goto fail;
-    }
-
-    desc->nb_objects = 1;
-    desc->objects[0].fd = mpp_buffer_get_fd(buffer);
-    desc->objects[0].size = mpp_buffer_get_size(buffer);
-
-    desc->nb_layers = 1;
-    layer = &desc->layers[0];
-    layer->format = drmformat;
-    layer->nb_planes = 2;
-
-    layer->planes[0].object_index = 0;
-    layer->planes[0].offset = 0;
-    layer->planes[0].pitch = mpp_frame_get_hor_stride(mppframe);
-
-    layer->planes[1].object_index = 0;
-    layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mppframe);
-    layer->planes[1].pitch = layer->planes[0].pitch;
-
-    // we also allocate a struct in buf[0] that will allow to hold additionnal information
-    // for releasing properly MPP frames and decoder
-    framecontextref = av_buffer_allocz(sizeof(*framecontext));
-    if (!framecontextref) {
-        ret = AVERROR(ENOMEM);
-        goto fail;
-    }
-
-    // MPP decoder needs to be closed only when all frames have been released.
-    framecontext = (RKMPPFrameContext *)framecontextref->data;
-    framecontext->decoder_ref = av_buffer_ref(rk_context->decoder_ref);
-    framecontext->frame = mppframe;
-
-    frame->data[0]  = (uint8_t *)desc;
-    frame->buf[0]   = av_buffer_create((uint8_t *)desc, sizeof(*desc), rkmpp_release_frame,
-                                       framecontextref, AV_BUFFER_FLAG_READONLY);
-
-    if (!frame->buf[0]) {
-        ret = AVERROR(ENOMEM);
-        goto fail;
-    }
-
-    frame->hw_frames_ctx = av_buffer_ref(decoder->frames_ref);
-    if (!frame->hw_frames_ctx) {
-        ret = AVERROR(ENOMEM);
-        goto fail;
-    }
-
     return 0;
 
 fail:
     if (mppframe)
         mpp_frame_deinit(&mppframe);
-
-    if (framecontext)
-        av_buffer_unref(&framecontext->decoder_ref);
-
-    if (framecontextref)
-        av_buffer_unref(&framecontextref);
-
-    if (desc)
-        av_free(desc);
-
     return ret;
 }
 
@@ -720,19 +810,13 @@ static void rkmpp_flush(AVCodecContext *avctx)
     decoder->mpi->reset(decoder->ctx);
 
     decoder->eos = 0;
-    decoder->softconvert = 0;
+    decoder->norga = 0;
 
     decoder->last_fps_time = decoder->frames = 0;
 
     av_packet_unref(&decoder->packet);
 }
 
-static const AVCodecHWConfigInternal *const rkmpp_hw_configs[] = {
-    HW_CONFIG_INTERNAL(DRM_PRIME),
-    HW_CONFIG_INTERNAL(YUV420P),
-    NULL
-};
-
 #define RKMPP_DEC_CLASS(NAME) \
     static const AVClass rkmpp_##NAME##_dec_class = { \
         .class_name = "rkmpp_" #NAME "_dec", \
@@ -754,9 +838,12 @@ static const AVCodecHWConfigInternal *const rkmpp_hw_configs[] = {
         .p.priv_class   = &rkmpp_##NAME##_dec_class, \
         .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE, \
         .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_DRM_PRIME, \
+        												 AV_PIX_FMT_NV12, \
                                                          AV_PIX_FMT_YUV420P, \
                                                          AV_PIX_FMT_NONE}, \
-        .hw_configs     = rkmpp_hw_configs, \
+        .hw_configs     = (const AVCodecHWConfigInternal *const []) { HW_CONFIG_INTERNAL(DRM_PRIME), \
+                                                                      HW_CONFIG_INTERNAL(NV12), \
+                                                                      NULL}, \
         .bsfs           = BSFS, \
         .p.wrapper_name = "rkmpp", \
         .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE | FF_CODEC_CAP_CONTIGUOUS_BUFFERS \
-- 
2.40.0


From 3493b0fb8f50a57ce94c3544dfe899afe7800822 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Sun, 30 Apr 2023 16:52:57 +0200
Subject: [PATCH 21/24] more verbose stats with latency and MACD FPS

---
 libavcodec/rkmppdec.c | 56 ++++++++++++++++++++++++-------------------
 1 file changed, 31 insertions(+), 25 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index f71511d0d0..ecee5dd338 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -50,7 +50,7 @@
 #define DRM_FORMAT_NV15 fourcc_code('N', 'A', '1', '2')
 #endif
 
-#define FPS_UPDATE_INTERVAL     60
+#define FPS_FRAME_MACD 30
 
 typedef struct {
     MppCtx ctx;
@@ -65,8 +65,9 @@ typedef struct {
 
     char print_fps;
 
-    uint64_t last_fps_time;
+    uint64_t last_frame_time;
     uint64_t frames;
+    uint64_t latencies[FPS_FRAME_MACD];
 
     uint32_t mpp_format;
     uint32_t rga_informat;
@@ -392,34 +393,37 @@ fail:
     return ret;
 }
 
-static void rkmpp_update_fps(AVCodecContext *avctx)
+static uint64_t rkmpp_update_latency(AVCodecContext *avctx, uint64_t latency)
 {
     RKMPPDecodeContext *rk_context = avctx->priv_data;
     RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    struct timeval tv;
+    struct timespec tv;
     uint64_t curr_time;
-    float fps;
+    float fps = 0.0f;
 
     if (!decoder->print_fps)
-        return;
-
-    if (!decoder->last_fps_time) {
-        gettimeofday(&tv, NULL);
-        decoder->last_fps_time = tv.tv_sec * 1000 + tv.tv_usec / 1000;
-    }
-
-    if (++decoder->frames % FPS_UPDATE_INTERVAL)
-        return;
-
-    gettimeofday(&tv, NULL);
-    curr_time = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+        return 0;
 
-    fps = 1000.0f * FPS_UPDATE_INTERVAL / (curr_time - decoder->last_fps_time);
-    decoder->last_fps_time = curr_time;
+    clock_gettime(CLOCK_MONOTONIC, &tv);
+    curr_time = tv.tv_sec * 10e5 + tv.tv_nsec / 10e2;
+    if (latency == -1){
+		latency = decoder->last_frame_time ? curr_time - decoder->last_frame_time : 0;
+		decoder->last_frame_time = curr_time;
+		decoder->latencies[++decoder->frames % FPS_FRAME_MACD] = latency;
+		return latency;
+    } else if (latency == 0 || decoder->frames < FPS_FRAME_MACD) {
+    	fps = -1.0f;
+    } else {
+	   for(int i = 0; i < FPS_FRAME_MACD; i++) {
+		  fps += decoder->latencies[i];
+	   }
+    	fps = FPS_FRAME_MACD * 1000000.0f / fps;
+    }
+	av_log(avctx, AV_LOG_INFO,
+		   "[FFMPEG RKMPP] FPS(MACD%d): %6.1f || Frames: %" PRIu64 " || Latency: %" PRIu64 "us || Buffer Delay %" PRIu64 "us\n",
+		   FPS_FRAME_MACD, fps, decoder->frames, latency, (uint64_t)(curr_time - decoder->last_frame_time));
 
-    av_log(avctx, AV_LOG_INFO,
-           "[FFMPEG RKMPP] FPS: %6.1f || Frames: %" PRIu64 "\n",
-           fps, decoder->frames);
+    return 0;
 }
 
 static int rkmpp_set_drm_buf(AVCodecContext *avctx, AVFrame *frame, MppFrame mppframe)
@@ -566,7 +570,7 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
     MppFrame mppframe = NULL;
     MppBuffer buffer = NULL;
-    int ret, mode;
+    int ret, mode, latency;
 
     // should not provide any frame after EOS
     if (decoder->eos)
@@ -658,7 +662,7 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
         goto fail;
     }
 
-    rkmpp_update_fps(avctx);
+    latency = rkmpp_update_latency(avctx, -1);
 
     if(!decoder->buffer_callback){
     	ret = AVERROR_UNKNOWN;
@@ -673,6 +677,8 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
         goto fail;
     }
 
+    latency = rkmpp_update_latency(avctx, latency);
+
     // setup general frame fields
     frame->format           = avctx->pix_fmt;
     frame->width            = mpp_frame_get_width(mppframe);
@@ -812,7 +818,7 @@ static void rkmpp_flush(AVCodecContext *avctx)
     decoder->eos = 0;
     decoder->norga = 0;
 
-    decoder->last_fps_time = decoder->frames = 0;
+    decoder->last_frame_time = decoder->frames = 0;
 
     av_packet_unref(&decoder->packet);
 }
-- 
2.40.0


From 893dca97e199609f22a73082af1eba87b6512530 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Mon, 1 May 2023 19:00:21 +0200
Subject: [PATCH 22/24] Allow users to choose pix_fmt using
 "FFMPEG_RKMPP_PIXFMT" env variable. Valid options are: YUV420P, YUV420PSOFT,
 NV12, DRMPRIME. Case sensitive

---
 libavcodec/rkmppdec.c | 25 +++++++++++++++++++------
 1 file changed, 19 insertions(+), 6 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index ecee5dd338..4f9ecb0155 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -75,7 +75,6 @@ typedef struct {
     uint32_t drm_format;
     uint32_t sw_format;
     int rga_fd;
-    int8_t rgafbc;
     int8_t norga;
     int (*buffer_callback)(struct AVCodecContext *avctx, struct AVFrame *frame, MppFrame mppframe);
 
@@ -287,8 +286,6 @@ static int rkmpp_init_decoder(AVCodecContext *avctx)
     char *env;
     int ret;
 
-    avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);
-
     // create a decoder and a ref to it
     decoder = av_mallocz(sizeof(RKMPPDecoder));
     if (!decoder) {
@@ -350,8 +347,24 @@ static int rkmpp_init_decoder(AVCodecContext *avctx)
        goto fail;
     }
 
-    env = getenv("FFMPEG_RKMPP_NORGA");
-    if (env != NULL)
+    avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);
+
+    // override the the pixfmt according env variable
+    env = getenv("FFMPEG_RKMPP_PIXFMT");
+    if(env != NULL){
+        if(!strcmp(env, "YUV420P"))
+        	avctx->pix_fmt = AV_PIX_FMT_YUV420P;
+        else if (!strcmp(env, "NV12"))
+        	avctx->pix_fmt = AV_PIX_FMT_NV12;
+    	else if(!strcmp(env, "DRMPRIME"))
+    		avctx->pix_fmt = AV_PIX_FMT_DRM_PRIME;
+        else if(!strcmp(env, "YUV420PSOFT")){
+           	avctx->pix_fmt = AV_PIX_FMT_YUV420P;
+           	decoder->norga = 1;
+        }
+    }
+
+    if (decoder->norga)
         decoder->rga_fd = -1;
     else {
         decoder->rga_fd = open("/dev/rga", O_RDWR);
@@ -844,8 +857,8 @@ static void rkmpp_flush(AVCodecContext *avctx)
         .p.priv_class   = &rkmpp_##NAME##_dec_class, \
         .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE, \
         .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_DRM_PRIME, \
-        												 AV_PIX_FMT_NV12, \
                                                          AV_PIX_FMT_YUV420P, \
+        												 AV_PIX_FMT_NV12, \
                                                          AV_PIX_FMT_NONE}, \
         .hw_configs     = (const AVCodecHWConfigInternal *const []) { HW_CONFIG_INTERNAL(DRM_PRIME), \
                                                                       HW_CONFIG_INTERNAL(NV12), \
-- 
2.40.0


From 7612f91257a22339bfde5e3258b4b8c2671bb876 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Mon, 1 May 2023 20:03:53 +0200
Subject: [PATCH 23/24] Workaround for Mpp bug, where color primaries, trc and
 colorspace is giving wrong UNSPECIFIED values

---
 libavcodec/rkmppdec.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 4f9ecb0155..60f1506804 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -703,6 +703,12 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
     frame->color_trc        = mpp_frame_get_color_trc(mppframe);
     frame->colorspace       = mpp_frame_get_colorspace(mppframe);
 
+    // when mpp can not determine the color space, it returns reserved (0) value
+    // firefox does not understand this and instead expect unspecified (2) values
+    frame->color_primaries  = frame->color_primaries == AVCOL_PRI_RESERVED0 ? AVCOL_PRI_UNSPECIFIED : frame->color_primaries;
+    frame->color_trc		= frame->color_trc == AVCOL_TRC_RESERVED0 ? AVCOL_TRC_UNSPECIFIED : frame->color_trc;
+    frame->colorspace		= frame->colorspace == AVCOL_SPC_RGB ? AVCOL_SPC_UNSPECIFIED: frame->color_trc;
+
     mode = mpp_frame_get_mode(mppframe);
     frame->interlaced_frame = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_DEINTERLACED);
     frame->top_field_first  = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST);
-- 
2.40.0


From d8ecadf7de6ec350502b2613dfc34c815969b518 Mon Sep 17 00:00:00 2001
From: boogie <boogiepop@gmx.com>
Date: Tue, 2 May 2023 02:07:20 +0200
Subject: [PATCH 24/24] Log more understandable errors

---
 libavcodec/rkmppdec.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 60f1506804..c1d357344b 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -679,7 +679,7 @@ static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
 
     if(!decoder->buffer_callback){
     	ret = AVERROR_UNKNOWN;
-        av_log(avctx, AV_LOG_ERROR, "Decoder has no valid buffer_callback\n");
+    	av_log(avctx, AV_LOG_ERROR, "Decoder can't set output for MPP format:%d and AVFormat:%d.\n", decoder->mpp_format, avctx->pix_fmt);
         goto fail;
     }
 
-- 
2.40.0

